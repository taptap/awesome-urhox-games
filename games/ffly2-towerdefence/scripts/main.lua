--[[
2Då¡”é˜²æ¸¸æˆ

=== æ ¸å¿ƒç³»ç»Ÿ ===
1. å…³å¡é…ç½®
   - è·¯çº¿ç‚¹ï¼šæ•Œäººè¡Œè¿›è·¯å¾„çš„æ‹ç‚¹åæ ‡åˆ—è¡¨
   - æ³¢æ¬¡é…ç½®ï¼šæ¯æ³¢æ•Œäººç±»å‹ã€æ•°é‡ã€ç”Ÿæˆé—´éš”
   - é˜²å¾¡å¡”æ”¾ç½®ç‚¹ï¼šé¢„è®¾çš„å¯æ”¾ç½®é˜²å¾¡å¡”ä½ç½®
   - å…³å¡éš¾åº¦é€’å¢

2. æ•Œäººé…ç½®
   - å½¢çŠ¶ï¼šä½¿ç”¨ç®€å•å‡ ä½•å›¾å½¢ï¼ˆåœ†å½¢=æ™®é€šã€ä¸‰è§’å½¢=å¿«é€Ÿã€æ­£æ–¹å½¢=å¦å…‹ï¼‰
   - é¢œè‰²ï¼šç»¿è‰²=å¼±ã€é»„è‰²=ä¸­ç­‰ã€çº¢è‰²=å¼ºã€ç´«è‰²=boss
   - å±æ€§ï¼šç”Ÿå‘½å€¼ã€é˜²å¾¡åŠ›ã€ç§»åŠ¨é€Ÿåº¦ã€å‡»æ€å¥–åŠ±é‡‘å¸

3. é˜²å¾¡å¡”é…ç½®
   - ç±»å‹ï¼šç®­å¡”ï¼ˆå•ä½“å¿«é€Ÿï¼‰ã€ç‚®å¡”ï¼ˆèŒƒå›´ä¼¤å®³ï¼‰ã€å‡é€Ÿå¡”ï¼ˆå‡é€Ÿæ•ˆæœï¼‰ã€æ¿€å…‰å¡”ï¼ˆæŒç»­ä¼¤å®³ï¼‰
   - å½¢çŠ¶ï¼šä½¿ç”¨å‡ ä½•å›¾å½¢åŒºåˆ†å¡”ç±»å‹
   - å±æ€§ï¼šæ”»å‡»åŠ›ã€æ”»å‡»é€Ÿåº¦ã€æ”»å‡»èŒƒå›´ã€å»ºé€ è´¹ç”¨

4. é˜²å¾¡å¡”å‡çº§
   - æ¯ç§å¡”æœ‰3çº§ï¼Œå‡çº§æå‡å±æ€§
   - å‡çº§è´¹ç”¨ = å»ºé€ è´¹ç”¨ * ç­‰çº§
   - å¤–è§‚éšç­‰çº§å˜åŒ–ï¼ˆå¤§å°ã€é¢œè‰²æ·±åº¦ï¼‰

5. é˜²å¾¡å¡”æ‹†é™¤/å‡ºå”®
   - å‡ºå”®è¿”è¿˜ 60% ç´¯è®¡æŠ•å…¥é‡‘å¸
   - æ‹†é™¤åä½ç½®å¯é‡æ–°å»ºé€ 

=== ç»æµç³»ç»Ÿ ===
- åˆå§‹é‡‘å¸ï¼š100
- å‡»æ€å¥–åŠ±ï¼šæ ¹æ®æ•Œäººç±»å‹
- æ³¢æ¬¡å¥–åŠ±ï¼šå®Œæˆæ¯æ³¢é¢å¤–å¥–åŠ±

=== ç”Ÿå‘½ç³»ç»Ÿ ===
- åˆå§‹ç”Ÿå‘½ï¼š20
- æ•Œäººåˆ°è¾¾ç»ˆç‚¹æ‰£é™¤ç”Ÿå‘½ï¼ˆæ ¹æ®æ•Œäººç±»å‹ï¼‰
- ç”Ÿå‘½å½’é›¶æ¸¸æˆå¤±è´¥

=== UIç³»ç»Ÿ ===
1. æ¸¸æˆå¼€å§‹é¡µé¢
   - å…³å¡é€‰æ‹©ï¼ˆ3ä¸ªå…³å¡ï¼‰
   - æ¸¸æˆè¯´æ˜

2. æ¸¸æˆè¿›è¡Œé¡µé¢
   - é¡¶éƒ¨HUDï¼šé‡‘å¸ã€ç”Ÿå‘½ã€æ³¢æ¬¡ä¿¡æ¯
   - åº•éƒ¨ï¼šé˜²å¾¡å¡”é€‰æ‹©æ 
   - ç‚¹å‡»æ”¾ç½®ç‚¹ï¼šæ˜¾ç¤ºå»ºé€ /å‡çº§/å‡ºå”®èœå•

3. æ¸¸æˆç»“æŸé¡µé¢
   - èƒœåˆ©/å¤±è´¥çŠ¶æ€
   - ç»Ÿè®¡ä¿¡æ¯ï¼šå‡»æ€æ•°ã€é‡‘å¸æ”¶å…¥
   - é‡æ–°å¼€å§‹/è¿”å›èœå•
]]

-- ============================================================================
-- UrhoX 2D å¡”é˜²æ¸¸æˆ (Tower Defence Game)
-- ä½¿ç”¨ NanoVG å®ç°çš„å®Œæ•´å¡”é˜²æ¸¸æˆ
-- ============================================================================

require "LuaScripts/Utilities/Sample"

-- ============================================================================
-- 1. å…¨å±€å˜é‡å£°æ˜
-- ============================================================================
---@type Scene
local scene_ = nil
---@type Node
local cameraNode_ = nil
---@type NVGContextWrapper|nil
local nvg_ = nil

-- æ¸¸æˆé…ç½®
local CONFIG = {
    Title = "2D å¡”é˜²æ¸¸æˆ",
    Width = 1920,
    Height = 1080,
    PixelPerUnit = 100.0,
    
    -- æ¸¸æˆå‚æ•°
    InitialGold = 300,
    InitialLives = 20,
    SellRefundRate = 0.6,
    WaveBonus = 50,
    
    -- æ ¼å­å¤§å°ï¼ˆç”¨äºæ”¾ç½®å¡”ï¼‰
    GridSize = 48,
}

-- ============================================================================
-- æŠ€èƒ½æ ‘é…ç½®
-- ============================================================================
-- æŠ€èƒ½æ ‘åˆ†ä¸º4æ¡çº¿è·¯ï¼š
-- 1. tower   - é˜²å¾¡å¡”å¼ºåŒ–çº¿ï¼šæå‡é˜²å¾¡å¡”å±æ€§
-- 2. life    - ç”Ÿå‘½çº¿ï¼šæå‡ç”Ÿå‘½å€¼ä¸Šé™
-- 3. gold    - åˆå§‹é‡‘å¸çº¿ï¼šæå‡æ¸¸æˆå¼€å§‹æ—¶çš„é‡‘å¸
-- 4. income  - é‡‘å¸æ”¶ç›Šçº¿ï¼šæå‡é‡‘å¸è·å–æ•ˆç‡

local SkillTree = {
    -- ========================================
    -- é˜²å¾¡å¡”å¼ºåŒ–çº¿
    -- ========================================
    tower = {
        name = "é˜²å¾¡å¡”å¼ºåŒ–",
        icon = "tower",
        skills = {
            -- åŸºç¡€ä¼¤å®³æå‡
            tower_damage_1 = {
                name = "é”‹åˆ©ç®­å¤´",
                description = "æ‰€æœ‰é˜²å¾¡å¡”ä¼¤å®³ +10%",
                maxLevel = 3,
                prerequisite = nil,  -- æ— å‰ç½®ï¼Œå¯ç›´æ¥å­¦ä¹ 
                costs = {100, 200, 400},  -- æ¯çº§èŠ±è´¹çš„æŠ€èƒ½ç‚¹
                effects = {
                    {type = "tower_damage", value = 0.10},  -- ç­‰çº§1: +10%
                    {type = "tower_damage", value = 0.20},  -- ç­‰çº§2: +20%
                    {type = "tower_damage", value = 0.30},  -- ç­‰çº§3: +30%
                },
            },
            -- æ”»å‡»é€Ÿåº¦æå‡
            tower_speed_1 = {
                name = "å¿«é€Ÿè£…å¡«",
                description = "æ‰€æœ‰é˜²å¾¡å¡”æ”»å‡»é€Ÿåº¦ +10%",
                maxLevel = 3,
                prerequisite = "tower_damage_1",  -- éœ€è¦å…ˆå­¦ä¹ é”‹åˆ©ç®­å¤´
                costs = {150, 300, 600},
                effects = {
                    {type = "tower_attackspeed", value = 0.10},
                    {type = "tower_attackspeed", value = 0.20},
                    {type = "tower_attackspeed", value = 0.30},
                },
            },
            -- æ”»å‡»èŒƒå›´æå‡
            tower_range_1 = {
                name = "ç²¾å‡†ç„å‡†",
                description = "æ‰€æœ‰é˜²å¾¡å¡”æ”»å‡»èŒƒå›´ +15%",
                maxLevel = 2,
                prerequisite = "tower_speed_1",
                costs = {200, 500},
                effects = {
                    {type = "tower_range", value = 0.15},
                    {type = "tower_range", value = 0.30},
                },
            },
            -- ç®­å¡”ä¸“ç²¾
            tower_arrow_master = {
                name = "ç®­å¡”å¤§å¸ˆ",
                description = "ç®­å¡”ä¼¤å®³ +25%ï¼Œæ”»å‡»é€Ÿåº¦ +15%",
                maxLevel = 1,
                prerequisite = "tower_range_1",
                costs = {800},
                effects = {
                    {type = "arrow_damage", value = 0.25, type2 = "arrow_attackspeed", value2 = 0.15},
                },
            },
            -- ç‚®å¡”ä¸“ç²¾
            tower_cannon_master = {
                name = "ç‚®å¡”å¤§å¸ˆ",
                description = "ç‚®å¡”ä¼¤å®³ +20%ï¼Œæº…å°„èŒƒå›´ +30%",
                maxLevel = 1,
                prerequisite = "tower_range_1",
                costs = {800},
                effects = {
                    {type = "cannon_damage", value = 0.20, type2 = "cannon_splash", value2 = 0.30},
                },
            },
            -- å‡é€Ÿå¡”ä¸“ç²¾
            tower_slow_master = {
                name = "å‡é€Ÿå¤§å¸ˆ",
                description = "å‡é€Ÿå¡”æ•ˆæœ +20%ï¼ŒæŒç»­æ—¶é—´ +1ç§’",
                maxLevel = 1,
                prerequisite = "tower_range_1",
                costs = {800},
                effects = {
                    {type = "slow_effect", value = 0.20, type2 = "slow_duration", value2 = 1.0},
                },
            },
            -- æ¿€å…‰å¡”ä¸“ç²¾
            tower_laser_master = {
                name = "æ¿€å…‰å¤§å¸ˆ",
                description = "æ¿€å…‰å¡”ä¼¤å®³ +30%ï¼ŒèŒƒå›´ +20%",
                maxLevel = 1,
                prerequisite = "tower_range_1",
                costs = {800},
                effects = {
                    {type = "laser_damage", value = 0.30, type2 = "laser_range", value2 = 0.20},
                },
            },
        },
    },
    
    -- ========================================
    -- ç”Ÿå‘½çº¿
    -- ========================================
    life = {
        name = "ç”Ÿå‘½å¼ºåŒ–",
        icon = "heart",
        skills = {
            -- åŸºç¡€ç”Ÿå‘½æå‡
            life_base_1 = {
                name = "åšå›ºåŸå¢™",
                description = "åˆå§‹ç”Ÿå‘½å€¼ +5",
                maxLevel = 4,
                prerequisite = nil,
                costs = {80, 160, 320, 640},
                effects = {
                    {type = "max_lives", value = 5},
                    {type = "max_lives", value = 10},
                    {type = "max_lives", value = 15},
                    {type = "max_lives", value = 20},
                },
            },
            -- ç”Ÿå‘½æ¢å¤
            life_regen = {
                name = "åŸå¢™ä¿®å¤",
                description = "æ¯æ³¢ç»“æŸåæ¢å¤ç”Ÿå‘½å€¼",
                maxLevel = 3,
                prerequisite = "life_base_1",
                costs = {200, 400, 800},
                effects = {
                    {type = "life_regen_wave", value = 1},  -- æ¯æ³¢æ¢å¤1ç‚¹
                    {type = "life_regen_wave", value = 2},  -- æ¯æ³¢æ¢å¤2ç‚¹
                    {type = "life_regen_wave", value = 3},  -- æ¯æ³¢æ¢å¤3ç‚¹
                },
            },
            -- å‡å°‘ä¼¤å®³
            life_armor = {
                name = "é“ç”²æŠ¤åŸ",
                description = "æ•Œäººé€ æˆçš„ä¼¤å®³å‡å°‘",
                maxLevel = 2,
                prerequisite = "life_regen",
                costs = {500, 1000},
                effects = {
                    {type = "damage_reduction", value = 1},  -- æ¯ä¸ªæ•Œäººå°‘æ‰£1ç‚¹ç”Ÿå‘½
                    {type = "damage_reduction", value = 2},  -- æ¯ä¸ªæ•Œäººå°‘æ‰£2ç‚¹ç”Ÿå‘½
                },
            },
            -- æœ€åé˜²çº¿
            life_last_stand = {
                name = "æœ€åé˜²çº¿",
                description = "ç”Ÿå‘½å€¼é™åˆ°5ä»¥ä¸‹æ—¶ï¼Œé˜²å¾¡å¡”ä¼¤å®³ +50%",
                maxLevel = 1,
                prerequisite = "life_armor",
                costs = {1200},
                effects = {
                    {type = "last_stand_damage", value = 0.50, threshold = 5},
                },
            },
        },
    },
    
    -- ========================================
    -- åˆå§‹é‡‘å¸çº¿
    -- ========================================
    gold = {
        name = "åˆå§‹è´¢å¯Œ",
        icon = "coin",
        skills = {
            -- åŸºç¡€é‡‘å¸æå‡
            gold_start_1 = {
                name = "å®¶æ—é—äº§",
                description = "åˆå§‹é‡‘å¸ +50",
                maxLevel = 5,
                prerequisite = nil,
                costs = {50, 100, 200, 400, 800},
                effects = {
                    {type = "start_gold", value = 50},
                    {type = "start_gold", value = 100},
                    {type = "start_gold", value = 150},
                    {type = "start_gold", value = 200},
                    {type = "start_gold", value = 250},
                },
            },
            -- è´·æ¬¾ç³»ç»Ÿ
            gold_loan = {
                name = "çš‡å®¶è´·æ¬¾",
                description = "æ¸¸æˆå¼€å§‹æ—¶è·å¾—é¢å¤–é‡‘å¸ï¼ˆæ³¢æ¬¡å¥–åŠ±å‡å°‘10%ï¼‰",
                maxLevel = 2,
                prerequisite = "gold_start_1",
                costs = {300, 600},
                effects = {
                    {type = "start_gold", value = 100, type2 = "wave_bonus", value2 = -0.10},
                    {type = "start_gold", value = 200, type2 = "wave_bonus", value2 = -0.20},
                },
            },
            -- å»ºé€ æŠ˜æ‰£
            gold_discount = {
                name = "æ‰¹å‘é‡‡è´­",
                description = "é˜²å¾¡å¡”å»ºé€ è´¹ç”¨å‡å°‘",
                maxLevel = 3,
                prerequisite = "gold_start_1",
                costs = {200, 400, 800},
                effects = {
                    {type = "tower_cost", value = -0.05},  -- -5%
                    {type = "tower_cost", value = -0.10},  -- -10%
                    {type = "tower_cost", value = -0.15},  -- -15%
                },
            },
            -- å‡ºå”®å¢ç›Š
            gold_sell = {
                name = "ç²¾æ˜å•†äºº",
                description = "å‡ºå”®é˜²å¾¡å¡”è¿”è¿˜æ¯”ä¾‹æå‡",
                maxLevel = 2,
                prerequisite = "gold_discount",
                costs = {400, 800},
                effects = {
                    {type = "sell_refund", value = 0.10},  -- 60% -> 70%
                    {type = "sell_refund", value = 0.20},  -- 60% -> 80%
                },
            },
        },
    },
    
    -- ========================================
    -- é‡‘å¸æ”¶ç›Šçº¿
    -- ========================================
    income = {
        name = "é‡‘å¸æ”¶ç›Š",
        icon = "gold_bar",
        skills = {
            -- å‡»æ€å¥–åŠ±æå‡
            income_kill_1 = {
                name = "èµé‡‘çŒäºº",
                description = "å‡»æ€æ•Œäººè·å¾—çš„é‡‘å¸ +10%",
                maxLevel = 4,
                prerequisite = nil,
                costs = {100, 200, 400, 800},
                effects = {
                    {type = "kill_gold", value = 0.10},
                    {type = "kill_gold", value = 0.20},
                    {type = "kill_gold", value = 0.30},
                    {type = "kill_gold", value = 0.40},
                },
            },
            -- æ³¢æ¬¡å¥–åŠ±æå‡
            income_wave_1 = {
                name = "æˆ˜æœ¯èƒœåˆ©",
                description = "å®Œæˆæ³¢æ¬¡å¥–åŠ± +20",
                maxLevel = 3,
                prerequisite = "income_kill_1",
                costs = {150, 300, 600},
                effects = {
                    {type = "wave_bonus_flat", value = 20},
                    {type = "wave_bonus_flat", value = 40},
                    {type = "wave_bonus_flat", value = 60},
                },
            },
            -- è¿æ€å¥–åŠ±
            income_combo = {
                name = "è¿æ€å¥–åŠ±",
                description = "å¿«é€Ÿè¿ç»­å‡»æ€æ•Œäººè·å¾—é¢å¤–é‡‘å¸",
                maxLevel = 2,
                prerequisite = "income_wave_1",
                costs = {400, 800},
                effects = {
                    {type = "combo_bonus", value = 1, threshold = 3},   -- 3è¿æ€+1é‡‘å¸
                    {type = "combo_bonus", value = 2, threshold = 3},   -- 3è¿æ€+2é‡‘å¸
                },
            },
            -- åˆ©æ¯ç³»ç»Ÿ
            income_interest = {
                name = "é‡‘åº“åˆ©æ¯",
                description = "æ¯æ³¢å¼€å§‹æ—¶æ ¹æ®æŒæœ‰é‡‘å¸è·å¾—åˆ©æ¯",
                maxLevel = 3,
                prerequisite = "income_wave_1",
                costs = {500, 1000, 2000},
                effects = {
                    {type = "interest", value = 0.02},  -- 2%åˆ©æ¯
                    {type = "interest", value = 0.04},  -- 4%åˆ©æ¯
                    {type = "interest", value = 0.06},  -- 6%åˆ©æ¯
                },
            },
            -- å®Œç¾æ³¢æ¬¡
            income_perfect = {
                name = "å®Œç¾é˜²å®ˆ",
                description = "ä¸€æ³¢ä¸­ä¸æŸå¤±ç”Ÿå‘½ï¼Œé¢å¤–è·å¾—é‡‘å¸",
                maxLevel = 2,
                prerequisite = "income_combo",
                costs = {600, 1200},
                effects = {
                    {type = "perfect_wave_bonus", value = 30},
                    {type = "perfect_wave_bonus", value = 60},
                },
            },
        },
    },
}

-- ç©å®¶æŠ€èƒ½ç‚¹æ•°æ®ï¼ˆå­˜æ¡£ç”¨ï¼‰
local PlayerSkills = {
    skillPoints = 1000,         -- å¯ç”¨æŠ€èƒ½ç‚¹ï¼ˆåˆå§‹ç»™ä¸€äº›ç”¨äºæµ‹è¯•ï¼‰
    totalPointsEarned = 1000,   -- ç´¯è®¡è·å¾—çš„æŠ€èƒ½ç‚¹
    unlockedSkills = {},       -- å·²è§£é”çš„æŠ€èƒ½ {skillId = currentLevel}
}

-- æŠ€èƒ½æ ‘å¸ƒå±€é…ç½®
local SkillTreeLayout = {
    lineOrder = {"tower", "life", "gold", "income"},
    lineColors = {
        tower = {62, 213, 170},   -- é’è‰²
        life = {255, 100, 120},   -- çº¢è‰²
        gold = {255, 200, 80},    -- é‡‘è‰²
        income = {100, 180, 255}, -- è“è‰²
    },
    lineIcons = {
        tower = "ğŸ°",
        life = "â¤ï¸",
        gold = "ğŸ’°",
        income = "ğŸ“ˆ",
    },
}

-- è·å–æŠ€èƒ½å½“å‰ç­‰çº§
local function GetSkillLevel(skillId)
    return PlayerSkills.unlockedSkills[skillId] or 0
end

-- æ£€æŸ¥æŠ€èƒ½æ˜¯å¦å¯ä»¥å‡çº§
local function CanUpgradeSkill(lineId, skillId)
    local line = SkillTree[lineId]
    if not line then return false, "æŠ€èƒ½çº¿ä¸å­˜åœ¨" end
    
    local skill = line.skills[skillId]
    if not skill then return false, "æŠ€èƒ½ä¸å­˜åœ¨" end
    
    local currentLevel = GetSkillLevel(skillId)
    
    -- æ£€æŸ¥æ˜¯å¦å·²æ»¡çº§
    if currentLevel >= skill.maxLevel then
        return false, "æŠ€èƒ½å·²æ»¡çº§"
    end
    
    -- æ£€æŸ¥å‰ç½®æŠ€èƒ½
    if skill.prerequisite then
        local prereqLevel = GetSkillLevel(skill.prerequisite)
        if prereqLevel <= 0 then
            return false, "éœ€è¦å…ˆå­¦ä¹ å‰ç½®æŠ€èƒ½"
        end
    end
    
    -- æ£€æŸ¥æŠ€èƒ½ç‚¹
    local cost = skill.costs[currentLevel + 1]
    if PlayerSkills.skillPoints < cost then
        return false, "æŠ€èƒ½ç‚¹ä¸è¶³"
    end
    
    return true, nil
end

-- å‡çº§æŠ€èƒ½
local function UpgradeSkill(lineId, skillId)
    local canUpgrade, errorMsg = CanUpgradeSkill(lineId, skillId)
    if not canUpgrade then
        return false, errorMsg
    end
    
    local skill = SkillTree[lineId].skills[skillId]
    local currentLevel = GetSkillLevel(skillId)
    local cost = skill.costs[currentLevel + 1]
    
    PlayerSkills.skillPoints = PlayerSkills.skillPoints - cost
    PlayerSkills.unlockedSkills[skillId] = currentLevel + 1
    
    return true, nil
end

-- è·å–æŠ€èƒ½æ•ˆæœï¼ˆç”¨äºæ¸¸æˆä¸­åº”ç”¨ï¼‰
local function GetSkillEffect(effectType)
    local totalValue = 0
    
    for lineId, line in pairs(SkillTree) do
        for skillId, skill in pairs(line.skills) do
            local level = GetSkillLevel(skillId)
            if level > 0 then
                local effect = skill.effects[level]
                if effect and effect.type == effectType then
                    totalValue = totalValue + effect.value
                end
                if effect and effect.type2 == effectType then
                    totalValue = totalValue + effect.value2
                end
            end
        end
    end
    
    return totalValue
end

-- æ¸¸æˆçŠ¶æ€
local GameState = {
    MENU = "menu",
    PLAYING = "playing",
    PAUSED = "paused",
    VICTORY = "victory",
    DEFEAT = "defeat",
}

-- é‡ç½®æ‰€æœ‰æŠ€èƒ½ï¼ˆè¿”è¿˜æ‰€æœ‰å·²èŠ±è´¹çš„æŠ€èƒ½ç‚¹ï¼‰
local function ResetAllSkills()
    local refundedPoints = 0
    for lineId, line in pairs(SkillTree) do
        for skillId, skill in pairs(line.skills) do
            local level = GetSkillLevel(skillId)
            if level > 0 then
                -- è®¡ç®—å·²èŠ±è´¹çš„æŠ€èƒ½ç‚¹
                for i = 1, level do
                    refundedPoints = refundedPoints + skill.costs[i]
                end
            end
        end
    end
    PlayerSkills.unlockedSkills = {}
    PlayerSkills.skillPoints = PlayerSkills.skillPoints + refundedPoints
    return refundedPoints
end

local currentState_ = GameState.MENU
local selectedLevel_ = 1

-- ç©å®¶æ•°æ®
local playerGold_ = CONFIG.InitialGold
local playerLives_ = CONFIG.InitialLives
local currentWave_ = 0
local totalKills_ = 0
local totalGoldEarned_ = 0

-- æ¸¸æˆæ—¶é—´
local gameTime_ = 0
local waveTimer_ = 0
local waveDelay_ = 3.0  -- æ³¢æ¬¡é—´éš”

-- ============================================================================
-- 2. æ•Œäººé…ç½®
-- ============================================================================
local EnemyTypes = {
    -- æ™®é€šæ•Œäººï¼ˆåœ†å½¢ï¼‰
    normal = {
        shape = "circle",
        color = {100, 200, 100},  -- ç»¿è‰²
        health = 100,
        defense = 0,
        speed = 90,
        reward = 10,
        damage = 1,
        size = 22,
    },
    -- å¿«é€Ÿæ•Œäººï¼ˆä¸‰è§’å½¢ï¼‰
    fast = {
        shape = "triangle",
        color = {255, 200, 50},  -- é»„è‰²
        health = 60,
        defense = 0,
        speed = 180,
        reward = 15,
        damage = 1,
        size = 20,
    },
    -- å¦å…‹æ•Œäººï¼ˆæ­£æ–¹å½¢ï¼‰
    tank = {
        shape = "square",
        color = {200, 100, 100},  -- çº¢è‰²
        health = 300,
        defense = 5,
        speed = 52,
        reward = 25,
        damage = 3,
        size = 25,
    },
    -- Bossæ•Œäººï¼ˆå…­è¾¹å½¢ï¼‰
    boss = {
        shape = "hexagon",
        color = {180, 100, 220},  -- ç´«è‰²
        health = 1000,
        defense = 10,
        speed = 38,
        reward = 100,
        damage = 10,
        size = 40,
    },
    -- æˆ˜è½¦æ•Œäººï¼ˆå¤§åœ†å½¢å†…å«8ä¸ªå°åœ†å½¢ï¼Œæ­»äº¡ååˆ†è£‚ï¼‰
    chariot = {
        shape = "chariot",
        color = {255, 150, 100},  -- æ©™è‰²
        health = 500,
        defense = 8,
        speed = 45,
        reward = 50,
        damage = 5,
        size = 30,
        spawnOnDeath = "normal",  -- æ­»äº¡åç”Ÿæˆçš„æ•Œäººç±»å‹
        spawnCount = 8,           -- ç”Ÿæˆæ•°é‡
    },
}

-- ============================================================================
-- 3. é˜²å¾¡å¡”é…ç½®
-- ============================================================================
local TowerTypes = {
    -- ç®­å¡”ï¼ˆä¸‰è§’å½¢ï¼‰- å•ä½“å¿«é€Ÿæ”»å‡»
    arrow = {
        name = "ç®­å¡”",
        shape = "triangle",
        color = {100, 150, 255},  -- è“è‰²
        damage = 25,
        attackSpeed = 2.0,  -- æ¯ç§’æ”»å‡»æ¬¡æ•°
        range = 240,
        cost = 50,
        projectileSpeed = 1200,
        projectileType = "arrow",
        description = "å¿«é€Ÿæ”»å‡»å•ä½“æ•Œäºº",
    },
    -- ç‚®å¡”ï¼ˆåœ†å½¢ï¼‰- èŒƒå›´ä¼¤å®³
    cannon = {
        name = "ç‚®å¡”",
        shape = "circle",
        color = {255, 150, 50},  -- æ©™è‰²
        damage = 35,
        attackSpeed = 0.8,
        range = 220,
        cost = 80,
        projectileSpeed = 800,
        projectileType = "cannonball",
        splashRadius = 75,
        description = "èŒƒå›´ä¼¤å®³ï¼Œæ”»å‡»é€Ÿåº¦è¾ƒæ…¢",
    },
    -- å‡é€Ÿå¡”ï¼ˆè±å½¢ï¼‰- èŒƒå›´å‡é€Ÿæ•ˆæœ
    slow = {
        name = "å‡é€Ÿå¡”",
        shape = "diamond",
        color = {150, 220, 255},  -- æµ…è“è‰²
        damage = 10,
        attackSpeed = 0.5,  -- è„‰å†²é¢‘ç‡
        range = 200,  -- èŒƒå›´ç¨å¤§
        cost = 60,
        projectileType = "aura",  -- å…‰ç¯å‹æ”»å‡»
        slowEffect = 0.3,  -- å‡é€Ÿ50%
        slowDuration = 0.7,
        description = "èŒƒå›´å‡é€Ÿæ‰€æœ‰æ•Œäºº",
    },
    -- æ¿€å…‰å¡”ï¼ˆæ­£æ–¹å½¢ï¼‰- æŒç»­ä¼¤å®³
    laser = {
        name = "æ¿€å…‰å¡”",
        shape = "square",
        color = {255, 100, 100},  -- çº¢è‰²
        damage = 40,  -- æ¯ç§’ä¼¤å®³
        attackSpeed = 0,  -- æŒç»­æ”»å‡»
        range = 260,
        cost = 100,
        projectileType = "laser",
        description = "æŒç»­ç…§å°„é€ æˆä¼¤å®³",
    },
}

-- å‡çº§ç³»æ•°
local UpgradeMultipliers = {
    [1] = { damage = 1.0, range = 1.0, attackSpeed = 1.0, cost = 1.0 },
    [2] = { damage = 1.5, range = 1.1, attackSpeed = 1.2, cost = 1.5 },
    [3] = { damage = 2.2, range = 1.2, attackSpeed = 1.4, cost = 2.0 },
}

-- ============================================================================
-- 4. å…³å¡é…ç½®
-- ============================================================================
local Levels = {
    -- å…³å¡1ï¼šç®€å•
    [1] = {
        name = "è‰åŸå°å¾„",
        description = "é€‚åˆæ–°æ‰‹çš„ç®€å•å…³å¡",
        -- æ•Œäººè·¯å¾„ç‚¹ (1920x1080)
        path = {
            {x = 500, y = 350},
            {x = 1000, y = 350},
            {x = 1000, y = 750},
            {x = 500, y = 750},
        },
        -- é˜²å¾¡å¡”æ”¾ç½®ç‚¹ (1920x1080) - è·ç¦»è·¯çº¿è‡³å°‘100åƒç´ 
        towerSpots = {
            -- ä¸Šæ–¹åŒºåŸŸ (y < 200)
            {x = 700, y = 250},
			{x = 800, y = 450},
			{x = 900, y = 250},
			
			{x = 1100, y = 550},

            {x = 700, y = 850},
			{x = 800, y = 650},
			{x = 900, y = 850},
        },
        -- æ³¢æ¬¡é…ç½®
        waves = {
            { enemies = { {type = "normal", count = 5, interval = 1.0} } },
            { enemies = { {type = "normal", count = 8, interval = 0.8} } },
            { enemies = { {type = "normal", count = 5, interval = 1.0}, {type = "fast", count = 3, interval = 0.6} } },
            { enemies = { {type = "fast", count = 8, interval = 0.5} } },
            { enemies = { {type = "normal", count = 5, interval = 0.8}, {type = "tank", count = 2, interval = 2.0} } },
            { enemies = { {type = "chariot", count = 1, interval = 0}, {type = "normal", count = 5, interval = 0.8} } },
            { enemies = { {type = "tank", count = 5, interval = 1.5} } },
            { enemies = { {type = "normal", count = 10, interval = 0.5}, {type = "fast", count = 5, interval = 0.4} } },
            { enemies = { {type = "chariot", count = 2, interval = 3.0} } },
            { enemies = { {type = "boss", count = 1, interval = 0} } },
        },
        backgroundColor = {35, 35, 55},  -- æ·±è“ç´«è‰²
    },
    -- å…³å¡2ï¼šä¸­ç­‰
    [2] = {
        name = "æ²™æ¼ è¿·å®«",
        description = "å¤æ‚çš„è·¯å¾„ï¼Œæ›´å¤šæ•Œäºº",
        path = {
            {x = 500, y = 500},
            {x = 1300, y = 500},
            {x = 1300, y = 800},
            {x = 800, y = 800},
            {x = 800, y = 300},
        },
        towerSpots = {
            {x = 800-100, y = 500-100},
			{x = 800+100, y = 500+100},
			{x = 1300+100, y = 800+100},
			{x = 800-100, y = 800-100},
        },
        waves = {
            { enemies = { {type = "normal", count = 8, interval = 0.8} } },
            { enemies = { {type = "fast", count = 10, interval = 0.5} } },
            { enemies = { {type = "normal", count = 8, interval = 0.6}, {type = "fast", count = 5, interval = 0.4} } },
            { enemies = { {type = "tank", count = 5, interval = 1.2} } },
            { enemies = { {type = "chariot", count = 2, interval = 2.5} } },
            { enemies = { {type = "fast", count = 15, interval = 0.3} } },
            { enemies = { {type = "normal", count = 10, interval = 0.5}, {type = "tank", count = 5, interval = 1.0} } },
            { enemies = { {type = "chariot", count = 3, interval = 2.0}, {type = "fast", count = 8, interval = 0.4} } },
            { enemies = { {type = "tank", count = 8, interval = 0.8}, {type = "fast", count = 10, interval = 0.3} } },
            { enemies = { {type = "boss", count = 1, interval = 0}, {type = "chariot", count = 2, interval = 3.0} } },
            { enemies = { {type = "boss", count = 2, interval = 5.0} } },
        },
        backgroundColor = {40, 35, 50},  -- æ·±ç´«è‰²
    },
    -- å…³å¡3ï¼šå›°éš¾
    [3] = {
        name = "å†°å°è¦å¡",
        description = "æœ€ç»ˆæŒ‘æˆ˜ï¼Œæ•Œäººä¼—å¤š",
        path = {
            {x = 960, y = -56},
            {x = 960, y = 225},
            {x = 300, y = 225},
            {x = 300, y = 525},
            {x = 750, y = 525},
            {x = 750, y = 825},
            {x = 300, y = 825},
            {x = 300, y = 1080},
            {x = 1620, y = 1080},
            {x = 1620, y = 825},
            {x = 1170, y = 825},
            {x = 1170, y = 525},
            {x = 1620, y = 525},
            {x = 1620, y = 225},
            {x = 1995, y = 225},
        },
        -- æ”¾ç½®ç‚¹è·ç¦»è·¯çº¿è‡³å°‘100åƒç´ 
        towerSpots = {
            -- é¡¶éƒ¨åŒºåŸŸ (y < 125, è¿œç¦»x=960)
            {x = 150, y = 80}, {x = 500, y = 80}, {x = 700, y = 80},
            {x = 1150, y = 80}, {x = 1350, y = 80}, {x = 1800, y = 80},
            -- ä¸Šä¸­åŒºåŸŸ (325 < y < 425, è¿œç¦»x=300,750,960,1170,1620)
            {x = 500, y = 375}, {x = 950, y = 375},
            {x = 1350, y = 375}, {x = 1800, y = 375},
            -- ä¸­é—´åŒºåŸŸ (625 < y < 725, è¿œç¦»x=300,750,1170,1620)
            {x = 500, y = 675}, {x = 950, y = 675},
            {x = 1350, y = 675}, {x = 1800, y = 675},
            -- ä¸‹ä¸­åŒºåŸŸ (925 < y < 980, è¿œç¦»x=300,1620å’Œy=825,1080)
            {x = 500, y = 950}, {x = 700, y = 950},
            {x = 950, y = 950}, {x = 1150, y = 950},
            {x = 1350, y = 950},
        },
        waves = {
            { enemies = { {type = "fast", count = 15, interval = 0.4} } },
            { enemies = { {type = "normal", count = 15, interval = 0.5}, {type = "fast", count = 10, interval = 0.3} } },
            { enemies = { {type = "tank", count = 8, interval = 1.0} } },
            { enemies = { {type = "chariot", count = 3, interval = 2.0} } },
            { enemies = { {type = "fast", count = 20, interval = 0.25}, {type = "normal", count = 10, interval = 0.4} } },
            { enemies = { {type = "tank", count = 10, interval = 0.8}, {type = "fast", count = 15, interval = 0.3} } },
            { enemies = { {type = "chariot", count = 4, interval = 1.5}, {type = "tank", count = 5, interval = 1.0} } },
            { enemies = { {type = "boss", count = 1, interval = 0}, {type = "chariot", count = 3, interval = 2.0} } },
            { enemies = { {type = "tank", count = 15, interval = 0.6}, {type = "fast", count = 20, interval = 0.2} } },
            { enemies = { {type = "boss", count = 2, interval = 3.0}, {type = "chariot", count = 5, interval = 1.5} } },
            { enemies = { {type = "boss", count = 3, interval = 2.0}, {type = "fast", count = 30, interval = 0.15} } },
            { enemies = { {type = "boss", count = 5, interval = 1.5} } },
        },
        backgroundColor = {30, 40, 55},  -- æ·±è“è‰²
    },
    -- å…³å¡4ï¼šæµ‹è¯•å…³å¡ï¼ˆæˆ˜è½¦æµ‹è¯•ï¼‰
    [4] = {
        name = "æˆ˜è½¦æµ‹è¯•",
        description = "æµ‹è¯•æˆ˜è½¦åˆ†è£‚æœºåˆ¶",
        -- ä¸€æ¡ä»å·¦åˆ°å³çš„ç›´çº¿è·¯å¾„
        path = {
            {x = -75, y = 540},
            {x = 1995, y = 540},
        },
        -- è·¯å¾„ä¸Šä¸‹ä¸¤ä¾§çš„æ”¾ç½®ç‚¹ - è·ç¦»è·¯çº¿(y=540)è‡³å°‘100åƒç´ 
        towerSpots = {
            -- ä¸Šæ–¹ä¸€æ’ (y = 420, è·ç¦»è·¯çº¿120åƒç´ )
            {x = 200, y = 420}, {x = 400, y = 420}, {x = 600, y = 420}, {x = 800, y = 420},
            {x = 1000, y = 420}, {x = 1200, y = 420}, {x = 1400, y = 420}, {x = 1600, y = 420},
            -- ä¸‹æ–¹ä¸€æ’ (y = 660, è·ç¦»è·¯çº¿120åƒç´ )
            {x = 200, y = 660}, {x = 400, y = 660}, {x = 600, y = 660}, {x = 800, y = 660},
            {x = 1000, y = 660}, {x = 1200, y = 660}, {x = 1400, y = 660}, {x = 1600, y = 660},
        },
        -- åªæœ‰æˆ˜è½¦çš„æ³¢æ¬¡
        waves = {
            { enemies = { {type = "chariot", count = 1, interval = 0} } },
            { enemies = { {type = "chariot", count = 2, interval = 3.0} } },
            { enemies = { {type = "chariot", count = 3, interval = 2.5} } },
            { enemies = { {type = "chariot", count = 4, interval = 2.0} } },
            { enemies = { {type = "chariot", count = 5, interval = 1.5} } },
        },
        backgroundColor = {35, 38, 52},  -- æ·±ç°è“è‰²
    },
}

-- ============================================================================
-- 5. è¿è¡Œæ—¶æ•°æ®
-- ============================================================================
local enemies_ = {}          -- æ´»è·ƒçš„æ•Œäººåˆ—è¡¨
local towers_ = {}           -- å·²å»ºé€ çš„é˜²å¾¡å¡”
local projectiles_ = {}      -- é£è¡Œä¸­çš„å­å¼¹
local particles_ = {}        -- ç²’å­æ•ˆæœ

-- æ³¢æ¬¡ç”Ÿæˆå™¨çŠ¶æ€
local waveActive_ = false
local waveEnemyQueue_ = {}   -- å¾…ç”Ÿæˆçš„æ•Œäººé˜Ÿåˆ—
local spawnTimer_ = 0

-- UIçŠ¶æ€
local selectedTowerSpot_ = nil  -- å½“å‰é€‰ä¸­çš„æ”¾ç½®ç‚¹
local selectedTowerType_ = nil  -- å½“å‰é€‰ä¸­è¦å»ºé€ çš„å¡”ç±»å‹
local hoveredTower_ = nil       -- é¼ æ ‡æ‚¬åœçš„å¡”
local showTowerMenu_ = false    -- æ˜¾ç¤ºå¡”èœå•
local menuTower_ = nil          -- èœå•å¯¹åº”çš„å¡”æˆ–æ”¾ç½®ç‚¹
local showLevelSelectPanel_ = false  -- æ˜¾ç¤ºå…³å¡é€‰æ‹©é¢æ¿

-- å±å¹•éœ‡åŠ¨æ•ˆæœ
local screenShake_ = {
    timer = 0,           -- éœ‡åŠ¨å‰©ä½™æ—¶é—´
    intensity = 0,       -- éœ‡åŠ¨å¼ºåº¦
    offsetX = 0,         -- å½“å‰Xåç§»
    offsetY = 0,         -- å½“å‰Yåç§»
}

-- ============================================================================
-- 6. ç”Ÿå‘½å‘¨æœŸå‡½æ•°
-- ============================================================================

function Start()
    -- è®¾ç½®å›ºå®šçª—å£å¤§å°ï¼ˆä¸éšçª—å£ç¼©æ”¾ï¼‰
    local gfx = GetGraphics()
    gfx:SetMode(CONFIG.Width, CONFIG.Height)
    
    SampleStart()
    graphics.windowTitle = CONFIG.Title
    
    -- éšè—å³ä¸‹è§’çš„ Logoï¼ˆå¦åˆ™ä¼šé˜»æŒ¡æŒ‰é’®ç‚¹å‡»ï¼‰
    SetLogoVisible(false)
    
    InitNanoVG()
    CreateScene()
    SetupViewport()
    SubscribeToEvents()
    
    -- è®¾ç½®é¼ æ ‡æ¨¡å¼ä¸ºç»å¯¹æ¨¡å¼ï¼ˆæ˜¾ç¤ºé¼ æ ‡å…‰æ ‡ï¼‰
    input.mouseVisible = true
    input.mouseMode = MM_ABSOLUTE
    
    print("=== 2Då¡”é˜²æ¸¸æˆå¯åŠ¨ ===")
    print("ç‚¹å‡»é€‰æ‹©å…³å¡å¼€å§‹æ¸¸æˆ")
end

function Stop()
    if nvg_ ~= nil then
        nvgDelete(nvg_)
        nvg_ = nil
    end
end

-- ============================================================================
-- 7. åˆå§‹åŒ–å‡½æ•°
-- ============================================================================

function InitNanoVG()
    nvg_ = nvgCreate(1)
    if nvg_ == nil then
        print("âŒ ERROR: Failed to create NanoVG context!")
        return
    end
    
    local fontId = nvgCreateFont(nvg_, "sans", "Fonts/MiSans-Regular.ttf")
    if fontId == -1 then
        print("âš ï¸ WARNING: Failed to load default font")
    end
end

function CreateScene()
    scene_ = Scene()
    scene_:CreateComponent("Octree")
end

function SetupViewport()
    cameraNode_ = scene_:CreateChild("Camera")
    local camera = cameraNode_:CreateComponent("Camera")
    camera.orthographic = true
    camera.orthoSize = CONFIG.Height / CONFIG.PixelPerUnit
    cameraNode_.position = Vector3(0, 0, -10)
    
    local viewport = Viewport:new(scene_, camera)
    renderer:SetViewport(0, viewport)
end

function SubscribeToEvents()
    SubscribeToEvent("Update", "HandleUpdate")
    SubscribeToEvent("PreRenderUI", "HandleRender")
    SubscribeToEvent("MouseButtonDown", "HandleMouseDown")
    SubscribeToEvent("KeyDown", "HandleKeyDown")
end

-- ============================================================================
-- 8. æ¸¸æˆé€»è¾‘
-- ============================================================================

function ResetGame()
    enemies_ = {}
    towers_ = {}
    projectiles_ = {}
    particles_ = {}
    
    -- åº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼šåˆå§‹é‡‘å¸
    local startGoldBonus = GetSkillEffect("start_gold")
    playerGold_ = CONFIG.InitialGold + startGoldBonus
    
    -- åº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼šåˆå§‹ç”Ÿå‘½
    local maxLivesBonus = GetSkillEffect("max_lives")
    playerLives_ = CONFIG.InitialLives + maxLivesBonus
    
    currentWave_ = 0
    totalKills_ = 0
    totalGoldEarned_ = 0
    
    gameTime_ = 0
    waveTimer_ = 0
    waveActive_ = false
    waveEnemyQueue_ = {}
    spawnTimer_ = 0
    
    selectedTowerSpot_ = nil
    selectedTowerType_ = nil
    hoveredTower_ = nil
    showTowerMenu_ = false
    menuTower_ = nil
    
    -- æ¸…ç©ºæ‰€æœ‰å…³å¡çš„æ”¾ç½®ç‚¹ä¸Šçš„å¡”ç»‘å®š
    ClearAllTowerSpots()
end

-- æ¸…ç©ºæ‰€æœ‰æ”¾ç½®ç‚¹ä¸Šçš„å¡”ç»‘å®š
function ClearAllTowerSpots()
    for _, level in ipairs(Levels) do
        if level.towerSpots then
            for _, spot in ipairs(level.towerSpots) do
                spot.tower = nil
            end
        end
    end
end

function StartLevel(levelIndex)
    selectedLevel_ = levelIndex
    ResetGame()
    currentState_ = GameState.PLAYING
    print("å¼€å§‹å…³å¡: " .. Levels[levelIndex].name)
end

function StartNextWave()
    local level = Levels[selectedLevel_]
    if currentWave_ >= #level.waves then
        -- æ‰€æœ‰æ³¢æ¬¡å®Œæˆï¼Œèƒœåˆ©
        currentState_ = GameState.VICTORY
        return
    end
    
    currentWave_ = currentWave_ + 1
    waveActive_ = true
    waveEnemyQueue_ = {}
    
    local waveConfig = level.waves[currentWave_]
    for _, enemyGroup in ipairs(waveConfig.enemies) do
        for i = 1, enemyGroup.count do
            table.insert(waveEnemyQueue_, {
                type = enemyGroup.type,
                delay = (i - 1) * enemyGroup.interval
            })
        end
    end
    
    spawnTimer_ = 0
    print("æ³¢æ¬¡ " .. currentWave_ .. " å¼€å§‹ï¼æ•Œäººæ•°é‡: " .. #waveEnemyQueue_)
end

function SpawnEnemy(enemyType)
    local level = Levels[selectedLevel_]
    local config = EnemyTypes[enemyType]
    
    -- è®¡ç®—éšæœºä¾§æ–¹åç§»ï¼ˆå‚ç›´äºè·¯å¾„æ–¹å‘ï¼‰
    local laneOffset = (math.random() - 0.5) * 50  -- -25 åˆ° +25 çš„éšæœºåç§»
    
    -- è®¡ç®—åˆå§‹ä½ç½®å’Œæœå‘ï¼ˆåŸºäºç¬¬ä¸€æ®µè·¯å¾„ï¼‰
    local startX = level.path[1].x
    local startY = level.path[1].y
    local initialRotation = 0
    if #level.path >= 2 then
        local dx = level.path[2].x - level.path[1].x
        local dy = level.path[2].y - level.path[1].y
        local len = math.sqrt(dx * dx + dy * dy)
        if len > 0 then
            startX = startX + (-dy / len) * laneOffset
            startY = startY + (dx / len) * laneOffset
            initialRotation = math.atan2(dy, dx)  -- åˆå§‹æœå‘
        end
    end
    
    local enemy = {
        type = enemyType,
        x = startX,
        y = startY,
        health = config.health,
        maxHealth = config.health,
        defense = config.defense,
        speed = config.speed,
        reward = config.reward,
        damage = config.damage,
        size = config.size,
        pathIndex = 1,
        pathProgress = 0,
        slowTimer = 0,
        slowMultiplier = 1.0,
        -- è½¦é“åç§»ï¼ˆè®©æ•Œäººä¸èµ°åŒä¸€æ¡çº¿ï¼‰
        laneOffset = laneOffset,
        -- æ—‹è½¬ï¼ˆæœå‘å‰è¿›æ–¹å‘ï¼‰
        rotation = initialRotation,
        targetRotation = initialRotation,
        -- å—å‡»å¼¹ç°§åç§»æ•ˆæœ
        hitRecoilTimer = 0,
        hitRecoilDirX = 0,
        hitRecoilDirY = 0,
        hitRecoilIntensity = 0,
        hitRecoilOffsetX = 0,
        hitRecoilOffsetY = 0,
    }
    
    table.insert(enemies_, enemy)
end

-- æˆ˜è½¦åˆ†è£‚ï¼šåœ¨æŒ‡å®šä½ç½®ç”Ÿæˆå¤šä¸ªå°æ•Œäºº
function SpawnSplitEnemies(parentEnemy, childType, count)
    local config = EnemyTypes[childType]
    if not config then return end
    
    -- åˆ†è£‚ç‰¹æ•ˆ
    CreateSplitParticles(parentEnemy.x, parentEnemy.y)
    
    for i = 1, count do
        -- æ¯ä¸ªæ•Œäººæœ‰ä¸€ä¸ªæ•£å¼€æ–¹å‘ï¼ˆå‡åŒ€åˆ†å¸ƒåœ¨åœ†å‘¨ä¸Šï¼‰
        local scatterAngle = (i - 1) * (2 * math.pi / count) + (math.random() - 0.5) * 0.3
        
        -- æ¯ä¸ªåˆ†è£‚æ•Œäººæœ‰ç‹¬ç«‹çš„è½¦é“åç§»
        local laneOffset = (math.random() - 0.5) * 40
        
        local child = {
            type = childType,
            -- ä»çˆ¶æ•Œäººä¸­å¿ƒä½ç½®ç”Ÿæˆ
            x = parentEnemy.x,
            y = parentEnemy.y,
            health = config.health,
            maxHealth = config.health,
            defense = config.defense,
            speed = config.speed,
            reward = config.reward,
            damage = config.damage,
            size = config.size,
            pathIndex = parentEnemy.pathIndex,
            pathProgress = parentEnemy.pathProgress or 0,
            slowTimer = 0,
            slowMultiplier = 1.0,
            -- è½¦é“åç§»
            laneOffset = laneOffset,
            -- æ—‹è½¬ï¼ˆåˆå§‹æœå‘æ•£å¼€æ–¹å‘ï¼‰
            rotation = scatterAngle,
            targetRotation = scatterAngle,
            -- å—å‡»å¼¹ç°§åç§»æ•ˆæœ
            hitRecoilTimer = 0,
            hitRecoilDirX = 0,
            hitRecoilDirY = 0,
            hitRecoilIntensity = 0,
            hitRecoilOffsetX = 0,
            hitRecoilOffsetY = 0,
            -- æ•£å¼€é˜¶æ®µ
            scatterPhase = true,
            scatterAngle = scatterAngle,
            scatterDistance = 20 + math.random() * 20,  -- æ•£å¼€è·ç¦»
            scatterProgress = 0,
        }
        
        table.insert(enemies_, child)
    end
end

function UpdateEnemies(dt)
    local level = Levels[selectedLevel_]
    local path = level.path
    
    for i = #enemies_, 1, -1 do
        local enemy = enemies_[i]
        local config = EnemyTypes[enemy.type]
        
        -- æ›´æ–°å‡é€Ÿæ•ˆæœ
        if enemy.slowTimer > 0 then
            enemy.slowTimer = enemy.slowTimer - dt
            if enemy.slowTimer <= 0 then
                enemy.slowMultiplier = 1.0
            end
        end
        
        -- æ›´æ–°å—å‡»å¼¹ç°§åç§»æ•ˆæœ
        if enemy.hitRecoilTimer and enemy.hitRecoilTimer > 0 then
            enemy.hitRecoilTimer = enemy.hitRecoilTimer - dt
            local recoilDuration = 0.35
            local t = 1.0 - (enemy.hitRecoilTimer / recoilDuration)  -- t: 0 -> 1
            
            -- å¼¹ç°§å…¬å¼ï¼šå¿«é€Ÿåç§»ç„¶åå¼¹å›
            local damping = 4.0
            local frequency = 12.0
            local springValue = math.exp(-damping * t) * math.cos(frequency * t)
            
            local intensity = enemy.hitRecoilIntensity or 6
            enemy.hitRecoilOffsetX = (enemy.hitRecoilDirX or 0) * intensity * springValue
            enemy.hitRecoilOffsetY = (enemy.hitRecoilDirY or 0) * intensity * springValue
        else
            enemy.hitRecoilOffsetX = 0
            enemy.hitRecoilOffsetY = 0
        end
        
        -- æ•£å¼€é˜¶æ®µå¤„ç†ï¼ˆæˆ˜è½¦åˆ†è£‚åçš„æ•Œäººå…ˆå‘å¤–æ•£å¼€ï¼‰
        if enemy.scatterPhase then
            local scatterSpeed = 200  -- æ•£å¼€é€Ÿåº¦
            local moveDistance = scatterSpeed * dt
            enemy.scatterProgress = (enemy.scatterProgress or 0) + moveDistance
            
            -- å‘æ•£å¼€æ–¹å‘ç§»åŠ¨
            enemy.x = enemy.x + math.cos(enemy.scatterAngle) * moveDistance
            enemy.y = enemy.y + math.sin(enemy.scatterAngle) * moveDistance
            
            -- æ•£å¼€å®Œæˆåè½¬å…¥æ­£å¸¸ç§»åŠ¨
            if enemy.scatterProgress >= enemy.scatterDistance then
                enemy.scatterPhase = false
                -- é‡æ–°è®¡ç®—æ—‹è½¬è§’åº¦æœå‘è·¯å¾„æ–¹å‘
                if enemy.pathIndex < #path then
                    local targetPoint = path[enemy.pathIndex + 1]
                    local dx = targetPoint.x - enemy.x
                    local dy = targetPoint.y - enemy.y
                    enemy.targetRotation = math.atan2(dy, dx)
                end
            end
        else
        -- æ­£å¸¸è·¯å¾„ç§»åŠ¨ï¼ˆä¸‹é¢çš„ä»£ç å—ç¼©è¿›ä¸å˜ï¼‰
        
        -- ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªè·¯å¾„ç‚¹
        local targetIndex = enemy.pathIndex + 1
        if targetIndex <= #path then
            local currentPoint = path[enemy.pathIndex]
            local targetPoint = path[targetIndex]
            local laneOffset = enemy.laneOffset or 0
            
            -- è®¡ç®—å½“å‰è·¯å¾„æ®µçš„æ³•çº¿æ–¹å‘
            local pathDx = targetPoint.x - currentPoint.x
            local pathDy = targetPoint.y - currentPoint.y
            local pathLength = math.sqrt(pathDx * pathDx + pathDy * pathDy)
            
            local normalX = 0
            local normalY = 0
            if pathLength > 0 then
                normalX = -pathDy / pathLength
                normalY = pathDx / pathLength
            end
            
            -- è®¡ç®—å¸¦åç§»çš„å½“å‰æ®µèµ·ç‚¹å’Œç»ˆç‚¹
            local startX = currentPoint.x + normalX * laneOffset
            local startY = currentPoint.y + normalY * laneOffset
            local endX = targetPoint.x + normalX * laneOffset
            local endY = targetPoint.y + normalY * laneOffset
            
            -- å¦‚æœæœ‰ä¸‹ä¸€æ®µè·¯å¾„ï¼Œè®¡ç®—ä¸‹ä¸€æ®µçš„åç§»ç»ˆç‚¹ç”¨äºå¹³æ»‘è¿‡æ¸¡
            if targetIndex < #path then
                local nextPoint = path[targetIndex + 1]
                local nextDx = nextPoint.x - targetPoint.x
                local nextDy = nextPoint.y - targetPoint.y
                local nextLen = math.sqrt(nextDx * nextDx + nextDy * nextDy)
                if nextLen > 0 then
                    local nextNormalX = -nextDy / nextLen
                    local nextNormalY = nextDx / nextLen
                    -- åœ¨è½¬è§’å¤„ä½¿ç”¨ä¸¤ä¸ªæ³•çº¿çš„å¹³å‡å€¼ï¼Œä½¿è½¬å¼¯æ›´å¹³æ»‘
                    local avgNormalX = (normalX + nextNormalX) / 2
                    local avgNormalY = (normalY + nextNormalY) / 2
                    local avgLen = math.sqrt(avgNormalX * avgNormalX + avgNormalY * avgNormalY)
                    if avgLen > 0 then
                        avgNormalX = avgNormalX / avgLen
                        avgNormalY = avgNormalY / avgLen
                    end
                    -- è½¬è§’ç‚¹ä½¿ç”¨å¹³å‡æ³•çº¿
                    endX = targetPoint.x + avgNormalX * laneOffset
                    endY = targetPoint.y + avgNormalY * laneOffset
                end
            end
            
            -- è®¡ç®—æ•Œäººåˆ°ç›®æ ‡ç‚¹çš„è·ç¦»å’Œæ–¹å‘
            local dx = endX - enemy.x
            local dy = endY - enemy.y
            local dist = math.sqrt(dx * dx + dy * dy)
            
            -- æ›´æ–°ç›®æ ‡æ—‹è½¬è§’åº¦ï¼ˆæœå‘ç§»åŠ¨æ–¹å‘ï¼‰
            if dist > 0.1 then
                enemy.targetRotation = math.atan2(dy, dx)
            end
            
            -- å¹³æ»‘æ—‹è½¬æ’å€¼
            local rotationSpeed = 15.0  -- æ—‹è½¬é€Ÿåº¦ï¼ˆå¼§åº¦/ç§’ï¼‰
            local currentRot = enemy.rotation or 0
            local targetRot = enemy.targetRotation or 0
            
            -- è®¡ç®—æœ€çŸ­æ—‹è½¬æ–¹å‘
            local rotDiff = targetRot - currentRot
            -- å°†è§’åº¦å·®æ ‡å‡†åŒ–åˆ° -Ï€ åˆ° Ï€ ä¹‹é—´
            while rotDiff > math.pi do rotDiff = rotDiff - 2 * math.pi end
            while rotDiff < -math.pi do rotDiff = rotDiff + 2 * math.pi end
            
            -- åº”ç”¨æ—‹è½¬æ’å€¼
            local maxRotation = rotationSpeed * dt
            if math.abs(rotDiff) <= maxRotation then
                enemy.rotation = targetRot
            else
                if rotDiff > 0 then
                    enemy.rotation = currentRot + maxRotation
                else
                    enemy.rotation = currentRot - maxRotation
                end
            end
            
            local speed = enemy.speed * enemy.slowMultiplier
            local moveAmount = speed * dt
            
            if dist <= moveAmount then
                -- åˆ°è¾¾å½“å‰æ®µç»ˆç‚¹ï¼Œè¿›å…¥ä¸‹ä¸€æ®µ
                enemy.x = endX
                enemy.y = endY
                enemy.pathIndex = targetIndex
            else
                -- æ²¿ç€åç§»åçš„è·¯å¾„ç§»åŠ¨
                enemy.x = enemy.x + (dx / dist) * moveAmount
                enemy.y = enemy.y + (dy / dist) * moveAmount
            end
        else
            -- åˆ°è¾¾ç»ˆç‚¹
            -- åº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼šä¼¤å®³å‡å…
            local damageReduction = GetSkillEffect("damage_reduction")
            local actualDamage = math.max(1, enemy.damage - damageReduction)  -- æœ€å°‘æ‰£1ç‚¹
            playerLives_ = playerLives_ - actualDamage
            
            -- æ’­æ”¾æ•Œäººæ­»äº¡åŠ¨ç”»ï¼ˆçº¢è‰²ç²’å­è¡¨ç¤ºä¼¤å®³ï¼‰
            CreateEnemyReachEndParticles(enemy.x, enemy.y, config.color)
            
            -- è§¦å‘å±å¹•éœ‡åŠ¨ï¼Œå¼ºåº¦ä¸æ•Œäººé€ æˆçš„ä¼¤å®³ç›¸å…³
            local shakeIntensity = 8 + actualDamage * 3
            local shakeDuration = 0.25 + actualDamage * 0.05
            TriggerScreenShake(shakeIntensity, shakeDuration)
            
            table.remove(enemies_, i)
            
            if playerLives_ <= 0 then
                -- æ¸¸æˆå¤±è´¥æ—¶æ›´å¼ºçš„éœ‡åŠ¨
                TriggerScreenShake(25, 0.6)
                currentState_ = GameState.DEFEAT
            end
        end
        end -- ç»“æŸ scatterPhase else åˆ†æ”¯
        
        -- æ£€æŸ¥æ­»äº¡
        if enemy.health <= 0 then
            -- åº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼šå‡»æ€å¥–åŠ±
            local killGoldBonus = GetSkillEffect("kill_gold")
            local reward = math.floor(enemy.reward * (1 + killGoldBonus))
            playerGold_ = playerGold_ + reward
            totalGoldEarned_ = totalGoldEarned_ + reward
            totalKills_ = totalKills_ + 1
            
            -- æ­»äº¡ç²’å­æ•ˆæœ
            CreateDeathParticles(enemy.x, enemy.y, config.color)
            
            -- æˆ˜è½¦åˆ†è£‚é€»è¾‘ï¼šæ­»äº¡åç”Ÿæˆå¤šä¸ªå°æ•Œäºº
            if config.spawnOnDeath and config.spawnCount then
                SpawnSplitEnemies(enemy, config.spawnOnDeath, config.spawnCount)
            end
            
            table.remove(enemies_, i)
        end
    end
end

function UpdateTowers(dt)
    for _, tower in ipairs(towers_) do
        local config = TowerTypes[tower.type]
        local mult = UpgradeMultipliers[tower.level]
        
        -- åˆå§‹åŒ–æ”»å‡»åŠ¨ç”»çŠ¶æ€
        if tower.recoilTimer == nil then
            tower.recoilTimer = 0
            tower.recoilX = 0
            tower.recoilY = 0
            tower.scaleAnim = 1.0
            tower.rotation = 0        -- å¡”çš„å½“å‰æ—‹è½¬è§’åº¦
            tower.targetRotation = 0  -- ç›®æ ‡æ—‹è½¬è§’åº¦
        end
        
        -- æ›´æ–°æ”»å‡»åŠ¨ç”»ï¼ˆå¼¹ç°§æ•ˆæœï¼‰
        if tower.recoilTimer > 0 then
            tower.recoilTimer = tower.recoilTimer - dt
            local recoilDuration = 0.35  -- å»¶é•¿åŠ¨ç”»æ—¶é—´
            local t = 1.0 - (tower.recoilTimer / recoilDuration)  -- t: 0 -> 1
            
            if tower.type == "slow" then
                -- å‡é€Ÿå¡”å¼¹ç°§ç¼©æ”¾åŠ¨ç”»
                local damping = 4.0
                local frequency = 12.0
                local springValue = math.exp(-damping * t) * math.cos(frequency * t)
                tower.scaleAnim = 1.0 - springValue * 0.25  -- ç¼©æ”¾å¹…åº¦0.25
            else
                -- æ™®é€šå¡”å¼¹ç°§åååŠ›åŠ¨ç”»
                local recoilAmount = 10  -- åååŠ›æœ€å¤§è·ç¦»
                local damping = 3.5      -- é˜»å°¼ç³»æ•°ï¼ˆè¶Šå¤§è¡°å‡è¶Šå¿«ï¼‰
                local frequency = 10.0   -- æŒ¯è¡é¢‘ç‡
                
                -- é˜»å°¼å¼¹ç°§å…¬å¼ï¼šå¿«é€Ÿåé€€ç„¶åå¼¹å›
                local springValue = math.exp(-damping * t) * math.cos(frequency * t)
                
                tower.recoilX = tower.recoilDirX * recoilAmount * springValue
                tower.recoilY = tower.recoilDirY * recoilAmount * springValue
            end
        else
            tower.recoilX = 0
            tower.recoilY = 0
            tower.scaleAnim = 1.0
        end
        
        -- æ‰¾ç›®æ ‡
        local target = FindTarget(tower)
        tower.target = target
        
        if config.projectileType == "laser" then
            -- æ¿€å…‰å¡”æŒç»­æ”»å‡»ï¼ˆåº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼Œä¸è§¦å‘å—å‡»ç§»åŠ¨æ•ˆæœï¼‰
            if target then
                local damage = CalculateTowerDamage(tower.type, config.damage * mult.damage)
                DealDamage(target, damage, config, dt, nil, nil)
                
                -- æ¿€å…‰å‘½ä¸­æ—¶äº§ç”Ÿçº¢è‰²ç«èŠ±ç²’å­
                tower.laserParticleTimer = (tower.laserParticleTimer or 0) + dt
                if tower.laserParticleTimer >= 0.05 then  -- æ¯0.05ç§’ç”Ÿæˆä¸€æ¬¡ç²’å­
                    tower.laserParticleTimer = 0
                    CreateLaserHitParticles(target.x, target.y)
                end
                
                -- æ”»å‡»æ—¶æŒç»­è‡ªè½¬
                tower.isAttacking = true
                local spinSpeed = 4.0  -- è‡ªè½¬é€Ÿåº¦ï¼ˆå¼§åº¦/ç§’ï¼‰
                tower.rotation = tower.rotation + spinSpeed * dt
                -- ä¿æŒè§’åº¦åœ¨åˆç†èŒƒå›´å†…
                if tower.rotation > math.pi * 2 then
                    tower.rotation = tower.rotation - math.pi * 2
                end
            else
                -- æ²¡æœ‰ç›®æ ‡æ—¶ï¼Œé€æ¸å‡é€Ÿå¹¶å›æ­£åˆ°0
                tower.isAttacking = false
                local returnSpeed = 3.0  -- å›æ­£é€Ÿåº¦
                
                -- è®¡ç®—åˆ°0çš„æœ€çŸ­è·¯å¾„
                local angleDiff = 0 - tower.rotation
                while angleDiff > math.pi do angleDiff = angleDiff - 2 * math.pi end
                while angleDiff < -math.pi do angleDiff = angleDiff + 2 * math.pi end
                
                -- å¦‚æœè§’åº¦å¾ˆå°å°±ç›´æ¥å½’é›¶
                if math.abs(angleDiff) < 0.05 then
                    tower.rotation = 0
                else
                    tower.rotation = tower.rotation + angleDiff * returnSpeed * dt
                end
            end
        elseif tower.type == "slow" then
            -- å‡é€Ÿå¡”ï¼šèŒƒå›´æŒç»­å‡é€Ÿï¼ˆåº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼‰
            tower.attackTimer = tower.attackTimer + dt
            local attackSpeed = CalculateTowerAttackSpeed(tower.type, config.attackSpeed * mult.attackSpeed)
            local pulseInterval = 1.0 / attackSpeed
            
            if tower.attackTimer >= pulseInterval then
                tower.attackTimer = 0
                -- å¯¹èŒƒå›´å†…æ‰€æœ‰æ•Œäººæ–½åŠ å‡é€Ÿ
                local range = CalculateTowerRange(tower.type, config.range * mult.range)
                local hasTarget = false
                
                -- è®¡ç®—å¢å¼ºåçš„å‡é€Ÿæ•ˆæœ
                local slowEffect = CalculateSlowEffect(config.slowEffect)
                local slowDuration = CalculateSlowDuration(config.slowDuration)
                
                for _, enemy in ipairs(enemies_) do
                    local dx = enemy.x - tower.x
                    local dy = enemy.y - tower.y
                    local dist = math.sqrt(dx * dx + dy * dy)
                    
                    if dist <= range then
                        hasTarget = true
                        -- æ–½åŠ å‡é€Ÿæ•ˆæœï¼ˆåº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼‰
                        enemy.slowTimer = slowDuration
                        enemy.slowMultiplier = slowEffect
                        -- é€ æˆå°‘é‡ä¼¤å®³
                        local damage = CalculateTowerDamage(tower.type, config.damage * mult.damage)
                        DealDamage(enemy, damage, config, 0, tower.x, tower.y)
                    end
                end
                
                -- æœ‰ç›®æ ‡æ—¶æ’­æ”¾è„‰å†²ç‰¹æ•ˆå’Œç¼©æ”¾åŠ¨ç”»
                if hasTarget then
                    tower.pulseTimer = 0.3  -- è„‰å†²åŠ¨ç”»æŒç»­æ—¶é—´
                    tower.recoilTimer = 0.15  -- ç¼©æ”¾åŠ¨ç”»
                    CreateSlowPulseParticles(tower.x, tower.y, range)
                end
            end
            
            -- æ›´æ–°è„‰å†²åŠ¨ç”»
            if tower.pulseTimer and tower.pulseTimer > 0 then
                tower.pulseTimer = tower.pulseTimer - dt
            end
        else
            -- æ™®é€šå¡”æ”»å‡»ï¼ˆåº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼‰
            tower.attackTimer = tower.attackTimer + dt
            local attackSpeed = CalculateTowerAttackSpeed(tower.type, config.attackSpeed * mult.attackSpeed)
            local attackInterval = 1.0 / attackSpeed
            
            if target and tower.attackTimer >= attackInterval then
                tower.attackTimer = 0
                
                -- è®¡ç®—åååŠ›æ–¹å‘ï¼ˆç›®æ ‡çš„åæ–¹å‘ï¼‰
                local dx = target.x - tower.x
                local dy = target.y - tower.y
                local dist = math.sqrt(dx * dx + dy * dy)
                if dist > 0 then
                    tower.recoilDirX = -dx / dist
                    tower.recoilDirY = -dy / dist
                else
                    tower.recoilDirX = 0
                    tower.recoilDirY = 0
                end
                tower.recoilTimer = 0.35  -- å¼¹ç°§åååŠ›åŠ¨ç”»æŒç»­æ—¶é—´
                
                FireProjectile(tower, target, config, mult)
            end
        end
    end
end

function FindTarget(tower)
    local config = TowerTypes[tower.type]
    local mult = UpgradeMultipliers[tower.level]
    -- åº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼šæ”»å‡»èŒƒå›´
    local range = CalculateTowerRange(tower.type, config.range * mult.range)
    local level = Levels[selectedLevel_]
    local path = level.path
    
    local bestEnemy = nil
    local bestProgress = -1  -- è·¯å¾„è¿›åº¦ï¼ˆè¶Šå¤§è¶Šæ¥è¿‘ç»ˆç‚¹ï¼‰
    
    for _, enemy in ipairs(enemies_) do
        local dx = enemy.x - tower.x
        local dy = enemy.y - tower.y
        local dist = math.sqrt(dx * dx + dy * dy)
        
        -- åªè€ƒè™‘åœ¨æ”»å‡»èŒƒå›´å†…çš„æ•Œäºº
        if dist <= range then
            -- è®¡ç®—æ•Œäººçš„è·¯å¾„è¿›åº¦
            -- pathIndex è¡¨ç¤ºå·²ç»ç»è¿‡çš„è·¯å¾„ç‚¹æ•°é‡
            -- å†åŠ ä¸Šå½“å‰è·¯æ®µçš„è¡Œè¿›æ¯”ä¾‹ï¼ˆ0-1ï¼‰
            local progress = enemy.pathIndex
            
            -- è®¡ç®—åœ¨å½“å‰è·¯æ®µä¸Šçš„è¿›åº¦
            if enemy.pathIndex < #path then
                local nextPoint = path[enemy.pathIndex + 1]
                local segmentDx = nextPoint.x - path[enemy.pathIndex].x
                local segmentDy = nextPoint.y - path[enemy.pathIndex].y
                local segmentLength = math.sqrt(segmentDx * segmentDx + segmentDy * segmentDy)
                
                if segmentLength > 0 then
                    local enemyDx = enemy.x - path[enemy.pathIndex].x
                    local enemyDy = enemy.y - path[enemy.pathIndex].y
                    local enemyDist = math.sqrt(enemyDx * enemyDx + enemyDy * enemyDy)
                    progress = progress + (enemyDist / segmentLength)
                end
            end
            
            -- é€‰æ‹©è¿›åº¦æœ€å¤§çš„æ•Œäººï¼ˆæœ€æ¥è¿‘ç»ˆç‚¹ï¼‰
            if progress > bestProgress then
                bestProgress = progress
                bestEnemy = enemy
            end
        end
    end
    
    return bestEnemy
end

-- è®¡ç®—å¡”çš„æœ€ç»ˆä¼¤å®³ï¼ˆåº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼‰
function CalculateTowerDamage(towerType, baseDamage)
    -- é€šç”¨ä¼¤å®³åŠ æˆ
    local damageBonus = GetSkillEffect("tower_damage")
    
    -- å¡”ç±»å‹ä¸“ç²¾åŠ æˆ
    local typeBonus = GetSkillEffect(towerType .. "_damage")
    
    -- ä½è¡€é‡æ—¶çš„ä¼¤å®³åŠ æˆï¼ˆæœ€åé˜²çº¿ï¼‰
    local lastStandBonus = 0
    local maxLives = CONFIG.InitialLives + GetSkillEffect("max_lives")
    if playerLives_ <= 5 then
        lastStandBonus = GetSkillEffect("last_stand_damage")
    end
    
    return baseDamage * (1 + damageBonus + typeBonus + lastStandBonus)
end

-- è®¡ç®—å¡”çš„æ”»å‡»é€Ÿåº¦åŠ æˆ
function CalculateTowerAttackSpeed(towerType, baseSpeed)
    local speedBonus = GetSkillEffect("tower_attackspeed")
    local typeBonus = GetSkillEffect(towerType .. "_attackspeed")
    return baseSpeed * (1 + speedBonus + typeBonus)
end

-- è®¡ç®—å¡”çš„æ”»å‡»èŒƒå›´åŠ æˆ
function CalculateTowerRange(towerType, baseRange)
    local rangeBonus = GetSkillEffect("tower_range")
    local typeBonus = GetSkillEffect(towerType .. "_range")
    return baseRange * (1 + rangeBonus + typeBonus)
end

-- è®¡ç®—å‡é€Ÿå¡”æ•ˆæœåŠ æˆ
function CalculateSlowEffect(baseEffect)
    local slowBonus = GetSkillEffect("slow_effect")
    return math.min(0.9, baseEffect + slowBonus)  -- æœ€å¤šå‡é€Ÿ90%
end

-- è®¡ç®—å‡é€ŸæŒç»­æ—¶é—´åŠ æˆ
function CalculateSlowDuration(baseDuration)
    local durationBonus = GetSkillEffect("slow_duration")
    return baseDuration + durationBonus
end

-- è®¡ç®—ç‚®å¡”æº…å°„èŒƒå›´åŠ æˆ
function CalculateSplashRadius(baseRadius)
    local splashBonus = GetSkillEffect("cannon_splash")
    return baseRadius * (1 + splashBonus)
end

function FireProjectile(tower, target, config, mult)
    -- åº”ç”¨æŠ€èƒ½æ ‘åŠ æˆ
    local finalDamage = CalculateTowerDamage(tower.type, config.damage * mult.damage)
    local finalSplashRadius = config.splashRadius and CalculateSplashRadius(config.splashRadius) or nil
    
    local projectile = {
        x = tower.x,
        y = tower.y,
        targetEnemy = target,
        speed = config.projectileSpeed,
        damage = finalDamage,
        type = config.projectileType,
        splashRadius = finalSplashRadius,
        slowEffect = config.slowEffect,
        slowDuration = config.slowDuration,
    }
    
    table.insert(projectiles_, projectile)
end

function UpdateProjectiles(dt)
    for i = #projectiles_, 1, -1 do
        local proj = projectiles_[i]
        
        -- æ£€æŸ¥ç›®æ ‡æ˜¯å¦è¿˜å­˜åœ¨
        local targetExists = false
        for _, enemy in ipairs(enemies_) do
            if enemy == proj.targetEnemy then
                targetExists = true
                break
            end
        end
        
        if not targetExists then
            table.remove(projectiles_, i)
        else
            -- ç§»åŠ¨å‘ç›®æ ‡
            local target = proj.targetEnemy
            local dx = target.x - proj.x
            local dy = target.y - proj.y
            local dist = math.sqrt(dx * dx + dy * dy)
            
            local moveAmount = proj.speed * dt
            
            if dist <= moveAmount or dist <= target.size then
                -- å‡»ä¸­
                if proj.splashRadius then
                    -- èŒƒå›´ä¼¤å®³
                    for _, enemy in ipairs(enemies_) do
                        local edx = enemy.x - target.x
                        local edy = enemy.y - target.y
                        local edist = math.sqrt(edx * edx + edy * edy)
                        if edist <= proj.splashRadius then
                            DealDamage(enemy, proj.damage * (1 - edist / proj.splashRadius * 0.5), nil, nil, proj.x, proj.y)
                        end
                    end
                    -- çˆ†ç‚¸ç²’å­
                    CreateExplosionParticles(target.x, target.y)
                else
                    DealDamage(target, proj.damage, {slowEffect = proj.slowEffect, slowDuration = proj.slowDuration}, nil, proj.x, proj.y)
                    
                    -- ç®­å¡”å‘½ä¸­ç‰¹æ•ˆ
                    if proj.type == "arrow" then
                        CreateArrowHitParticles(target.x, target.y, proj.x, proj.y)
                    end
                end
                
                table.remove(projectiles_, i)
            else
                proj.x = proj.x + (dx / dist) * moveAmount
                proj.y = proj.y + (dy / dist) * moveAmount
            end
        end
    end
end

function DealDamage(enemy, damage, config, dt, sourceX, sourceY)
    local actualDamage = math.max(0, damage - enemy.defense)
    if dt then
		actualDamage = actualDamage * dt
	end
    enemy.health = enemy.health - actualDamage
    
    -- å—å‡»å¼¹ç°§åç§»æ•ˆæœï¼ˆå‘æ”»å‡»æ¥æºçš„åæ–¹å‘åç§»ï¼‰
    if actualDamage > 0 and sourceX and sourceY then
        local dx = enemy.x - sourceX
        local dy = enemy.y - sourceY
        local dist = math.sqrt(dx * dx + dy * dy)
        if dist > 0 then
            enemy.hitRecoilDirX = dx / dist
            enemy.hitRecoilDirY = dy / dist
        else
            enemy.hitRecoilDirX = 0
            enemy.hitRecoilDirY = 1
        end
        enemy.hitRecoilTimer = 0.35  -- å—å‡»åŠ¨ç”»æŒç»­æ—¶é—´
        enemy.hitRecoilIntensity = math.min(24, actualDamage / 8 + 8)  -- åç§»å¼ºåº¦ä¸ä¼¤å®³ç›¸å…³
    end
    
    -- å‡é€Ÿæ•ˆæœ
    if config and config.slowEffect then
        enemy.slowTimer = config.slowDuration
        enemy.slowMultiplier = config.slowEffect
    end
end

function UpdateParticles(dt)
    for i = #particles_, 1, -1 do
        local p = particles_[i]
        p.life = p.life - dt
        p.x = p.x + p.vx * dt
        p.y = p.y + p.vy * dt
        p.vy = p.vy + 200 * dt  -- é‡åŠ›
        
        if p.life <= 0 then
            table.remove(particles_, i)
        end
    end
end

function CreateDeathParticles(x, y, color)
    -- ä¸»è¦çˆ†ç‚¸ç²’å­
    for i = 1, 12 do
        local angle = (i / 12) * math.pi * 2
        local speed = 100 + math.random() * 80
        table.insert(particles_, {
            x = x,
            y = y,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed - 60,
            life = 0.6,
            maxLife = 0.6,
            color = color,
            size = 6 + math.random() * 4,
            type = "circle",
        })
    end
    -- ç«èŠ±ç²’å­
    for i = 1, 6 do
        local angle = math.random() * math.pi * 2
        local speed = 150 + math.random() * 100
        table.insert(particles_, {
            x = x,
            y = y,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed - 80,
            life = 0.3,
            maxLife = 0.3,
            color = {255, 255, 200},
            size = 3 + math.random() * 2,
            type = "spark",
        })
    end
end

-- ç®­å¡”å‘½ä¸­æ•Œäººæ—¶çš„å—å‡»ç‰¹æ•ˆ
function CreateArrowHitParticles(targetX, targetY, projX, projY)
    -- è®¡ç®—ç®­çŸ¢é£è¡Œæ–¹å‘
    local dx = targetX - projX
    local dy = targetY - projY
    local dist = math.sqrt(dx * dx + dy * dy)
    local dirX = dist > 0 and dx / dist or 0
    local dirY = dist > 0 and dy / dist or 1
    
    -- å†²å‡»ç²’å­ï¼ˆæ²¿ç®­çŸ¢æ–¹å‘æ•£å¼€ï¼‰
    for i = 1, 8 do
        local spreadAngle = (math.random() - 0.5) * math.pi * 0.8  -- æ•£å¼€è§’åº¦
        local baseAngle = math.atan2(dirY, dirX)
        local angle = baseAngle + spreadAngle
        local speed = 80 + math.random() * 60
        table.insert(particles_, {
            x = targetX,
            y = targetY,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed,
            life = 0.25 + math.random() * 0.15,
            maxLife = 0.4,
            color = {200, 200, 255},  -- æ·¡è“ç™½è‰²
            size = 3 + math.random() * 2,
            type = "spark",
        })
    end
    
    -- ç™½è‰²é—ªå…‰ç²’å­ï¼ˆä¸­å¿ƒçˆ†å‘ï¼‰
    for i = 1, 4 do
        local angle = math.random() * math.pi * 2
        local speed = 30 + math.random() * 40
        table.insert(particles_, {
            x = targetX,
            y = targetY,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed - 20,
            life = 0.15 + math.random() * 0.1,
            maxLife = 0.25,
            color = {255, 255, 255},  -- çº¯ç™½
            size = 4 + math.random() * 3,
            type = "circle",
        })
    end
    
    -- å°ç¢ç‰‡ç²’å­
    for i = 1, 5 do
        local angle = math.random() * math.pi * 2
        local speed = 50 + math.random() * 80
        table.insert(particles_, {
            x = targetX + (math.random() - 0.5) * 10,
            y = targetY + (math.random() - 0.5) * 10,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed - 40,
            life = 0.3 + math.random() * 0.2,
            maxLife = 0.5,
            color = {180, 180, 220},  -- æ·¡ç´«è“
            size = 2 + math.random() * 2,
            type = "circle",
        })
    end
end

-- æ¿€å…‰å¡”å‘½ä¸­æ•Œäººæ—¶çš„çº¢è‰²ç«èŠ±ç²’å­
function CreateLaserHitParticles(x, y)
    -- é£˜æ•£çš„çº¢è‰²ç«èŠ±ï¼ˆå‘ä¸Šé£˜æ•£ï¼‰
    for i = 1, 3 do
        local angle = -math.pi / 2 + (math.random() - 0.5) * math.pi * 0.8  -- ä¸»è¦å‘ä¸Š
        local speed = 40 + math.random() * 60
        table.insert(particles_, {
            x = x + (math.random() - 0.5) * 20,
            y = y + (math.random() - 0.5) * 20,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed - 30,  -- å‘ä¸Šåç§»
            life = 0.4 + math.random() * 0.3,
            maxLife = 0.7,
            color = {255, 80 + math.random(80), 50},  -- çº¢è‰²åˆ°æ©™è‰²
            size = 3 + math.random() * 3,
            type = "spark",
        })
    end
    
    -- å¶å°”äº§ç”Ÿè¾ƒå¤§çš„ç«èŠ±
    if math.random() < 0.3 then
        local angle = -math.pi / 2 + (math.random() - 0.5) * math.pi * 0.5
        local speed = 60 + math.random() * 40
        table.insert(particles_, {
            x = x,
            y = y,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed - 50,
            life = 0.5 + math.random() * 0.3,
            maxLife = 0.8,
            color = {255, 200, 100},  -- äº®é»„è‰²
            size = 5 + math.random() * 3,
            type = "spark",
        })
    end
end

-- æ•Œäººåˆ°è¾¾ç»ˆç‚¹æ—¶çš„ç‰¹æ®Šæ­»äº¡æ•ˆæœï¼ˆçº¢è‰²è­¦å‘Šç²’å­ï¼‰
function CreateEnemyReachEndParticles(x, y, enemyColor)
    -- çº¢è‰²è­¦å‘Šçˆ†ç‚¸
    for i = 1, 16 do
        local angle = (i / 16) * math.pi * 2
        local speed = 120 + math.random() * 100
        table.insert(particles_, {
            x = x,
            y = y,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed - 50,
            life = 0.5,
            maxLife = 0.5,
            color = {255, 50, 50},  -- çº¢è‰²
            size = 8 + math.random() * 6,
            type = "circle",
        })
    end
    -- æ•Œäººé¢œè‰²ç²’å­
    for i = 1, 10 do
        local angle = math.random() * math.pi * 2
        local speed = 80 + math.random() * 60
        table.insert(particles_, {
            x = x,
            y = y,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed - 40,
            life = 0.4,
            maxLife = 0.4,
            color = enemyColor,
            size = 5 + math.random() * 4,
            type = "circle",
        })
    end
    -- å‘ä¸Šé£˜æ•£çš„ä¼¤å®³æŒ‡ç¤ºç²’å­
    for i = 1, 6 do
        table.insert(particles_, {
            x = x + (math.random() - 0.5) * 30,
            y = y,
            vx = (math.random() - 0.5) * 40,
            vy = -150 - math.random() * 80,
            life = 0.7,
            maxLife = 0.7,
            color = {255, 100, 100},
            size = 4 + math.random() * 3,
            type = "spark",
        })
    end
    -- å†²å‡»æ³¢
    table.insert(particles_, {
        x = x,
        y = y,
        vx = 0,
        vy = 0,
        life = 0.3,
        maxLife = 0.3,
        color = {255, 80, 80},
        size = 60,
        type = "shockwave",
    })
end

function CreateExplosionParticles(x, y, radius)
    radius = radius or 60
    -- çˆ†ç‚¸æ ¸å¿ƒ
    for i = 1, 16 do
        local angle = (i / 16) * math.pi * 2
        local speed = 80 + math.random() * 60
        table.insert(particles_, {
            x = x,
            y = y,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed,
            life = 0.5,
            maxLife = 0.5,
            color = {255, 200, 100},
            size = 8 + math.random() * 6,
            type = "circle",
        })
    end
    -- å¤–åœˆå†²å‡»æ³¢
    table.insert(particles_, {
        x = x,
        y = y,
        vx = 0,
        vy = 0,
        life = 0.3,
        maxLife = 0.3,
        color = {255, 150, 50},
        size = radius,
        type = "shockwave",
    })
    -- çƒŸé›¾
    for i = 1, 8 do
        local offsetX = (math.random() - 0.5) * 40
        local offsetY = (math.random() - 0.5) * 40
        table.insert(particles_, {
            x = x + offsetX,
            y = y + offsetY,
            vx = (math.random() - 0.5) * 30,
            vy = -30 - math.random() * 20,
            life = 0.8,
            maxLife = 0.8,
            color = {100, 100, 100},
            size = 15 + math.random() * 10,
            type = "smoke",
        })
    end
end

-- å¡”æ”»å‡»é—ªå…‰æ•ˆæœ
function CreateMuzzleFlash(x, y, color)
    table.insert(particles_, {
        x = x,
        y = y,
        vx = 0,
        vy = 0,
        life = 0.1,
        maxLife = 0.1,
        color = color or {255, 255, 200},
        size = 25,
        type = "flash",
    })
end

-- å­å¼¹è½¨è¿¹æ•ˆæœ
function CreateTrailParticle(x, y, color)
    table.insert(particles_, {
        x = x,
        y = y,
        vx = (math.random() - 0.5) * 20,
        vy = (math.random() - 0.5) * 20,
        life = 0.2,
        maxLife = 0.2,
        color = color,
        size = 4,
        type = "trail",
    })
end

-- æˆ˜è½¦åˆ†è£‚ç‰¹æ•ˆ
function CreateSplitParticles(x, y)
    -- ä¸­å¿ƒçˆ†ç‚¸
    for i = 1, 20 do
        local angle = (i / 20) * math.pi * 2
        local speed = 120 + math.random() * 80
        table.insert(particles_, {
            x = x,
            y = y,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed,
            life = 0.6,
            maxLife = 0.6,
            color = {255, 150, 100},
            size = 8 + math.random() * 5,
            type = "circle",
        })
    end
    -- å†²å‡»æ³¢
    table.insert(particles_, {
        x = x,
        y = y,
        vx = 0,
        vy = 0,
        life = 0.4,
        maxLife = 0.4,
        color = {255, 200, 150},
        size = 80,
        type = "shockwave",
    })
end

-- å»ºé€ å¡”ç‰¹æ•ˆ
function CreateBuildParticles(x, y, color)
    for i = 1, 12 do
        local angle = (i / 12) * math.pi * 2
        table.insert(particles_, {
            x = x + math.cos(angle) * 40,
            y = y + math.sin(angle) * 40,
            vx = -math.cos(angle) * 80,
            vy = -math.sin(angle) * 80,
            life = 0.4,
            maxLife = 0.4,
            color = color,
            size = 6,
            type = "circle",
        })
    end
    -- å…‰æŸ±æ•ˆæœ
    table.insert(particles_, {
        x = x,
        y = y,
        vx = 0,
        vy = 0,
        life = 0.5,
        maxLife = 0.5,
        color = {255, 255, 255},
        size = 30,
        type = "beam",
    })
end

-- å—å‡»é—ªçƒæ•ˆæœ
function CreateHitParticles(x, y, color)
    for i = 1, 4 do
        local angle = math.random() * math.pi * 2
        local speed = 50 + math.random() * 30
        table.insert(particles_, {
            x = x,
            y = y,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed,
            life = 0.2,
            maxLife = 0.2,
            color = color or {255, 255, 255},
            size = 4,
            type = "spark",
        })
    end
end

-- æˆ˜è½¦åˆ†è£‚ç‰¹æ•ˆ
function CreateSplitParticles(x, y)
    -- ä¸­å¿ƒçˆ†ç‚¸å…‰ç¯
    table.insert(particles_, {
        x = x,
        y = y,
        vx = 0,
        vy = 0,
        life = 0.4,
        maxLife = 0.4,
        color = {255, 200, 100},
        size = 60,
        type = "split_ring",
    })
    -- å‘å¤–æ•£å°„çš„ç«èŠ±
    for i = 1, 16 do
        local angle = (i / 16) * math.pi * 2
        local speed = 150 + math.random() * 100
        table.insert(particles_, {
            x = x,
            y = y,
            vx = math.cos(angle) * speed,
            vy = math.sin(angle) * speed,
            life = 0.5,
            maxLife = 0.5,
            color = {255, 220, 150},
            size = 6 + math.random() * 4,
            type = "spark",
        })
    end
end

-- é‡‘å¸è·å–é£˜å­—
function CreateGoldPopup(x, y, amount)
    table.insert(particles_, {
        x = x,
        y = y,
        vx = 0,
        vy = -60,
        life = 1.0,
        maxLife = 1.0,
        color = {255, 220, 50},
        size = 24,
        type = "text",
        text = "+" .. amount,
    })
end

-- å‡é€Ÿæ•ˆæœç²’å­
function CreateSlowParticles(x, y)
    for i = 1, 3 do
        local angle = math.random() * math.pi * 2
        local dist = math.random() * 15
        table.insert(particles_, {
            x = x + math.cos(angle) * dist,
            y = y + math.sin(angle) * dist,
            vx = 0,
            vy = -40,
            life = 0.5,
            maxLife = 0.5,
            color = {150, 220, 255},
            size = 6,
            type = "snowflake",
        })
    end
end

-- å‡é€Ÿå¡”è„‰å†²ç‰¹æ•ˆ
function CreateSlowPulseParticles(x, y, range)
    -- æ‰©æ•£å†²å‡»æ³¢
    table.insert(particles_, {
        x = x,
        y = y,
        vx = 0,
        vy = 0,
        life = 0.3,
        maxLife = 0.3,
        color = {150, 220, 255},
        size = range,
        type = "slow_pulse",
    })
    -- é›ªèŠ±ç²’å­
    for i = 1, 12 do
        local angle = (i / 12) * math.pi * 2
        local dist = range * 0.8
        table.insert(particles_, {
            x = x + math.cos(angle) * dist,
            y = y + math.sin(angle) * dist,
            vx = math.cos(angle) * 20,
            vy = math.sin(angle) * 20 - 30,
            life = 0.6,
            maxLife = 0.6,
            color = {180, 230, 255},
            size = 8,
            type = "snowflake",
        })
    end
end

function BuildTower(spot, towerType)
    local config = TowerTypes[towerType]
    -- åº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼šå»ºé€ è´¹ç”¨æŠ˜æ‰£
    local costDiscount = GetSkillEffect("tower_cost")
    local actualCost = math.floor(config.cost * (1 + costDiscount))  -- costDiscountæ˜¯è´Ÿæ•°
    
    if playerGold_ >= actualCost then
        playerGold_ = playerGold_ - actualCost
        
        local tower = {
            type = towerType,
            x = spot.x,
            y = spot.y,
            level = 1,
            attackTimer = 0,
            totalCost = actualCost,
            target = nil,
            pulseTimer = 0,  -- å‡é€Ÿå¡”è„‰å†²åŠ¨ç”»
        }
        
        spot.tower = tower
        table.insert(towers_, tower)
        
        -- å»ºé€ ç‰¹æ•ˆ
        CreateBuildParticles(spot.x, spot.y, config.color)
        
        showTowerMenu_ = false
        print("å»ºé€  " .. config.name .. " èŠ±è´¹ " .. actualCost)
        return true
    else
        print("é‡‘å¸ä¸è¶³ï¼")
        return false
    end
end

function UpgradeTower(tower)
    if tower.level >= 3 then
        print("å·²è¾¾æœ€é«˜ç­‰çº§ï¼")
        return false
    end
    
    local config = TowerTypes[tower.type]
    local nextMult = UpgradeMultipliers[tower.level + 1]
    local upgradeCost = math.floor(config.cost * nextMult.cost)
    
    if playerGold_ >= upgradeCost then
        playerGold_ = playerGold_ - upgradeCost
        tower.level = tower.level + 1
        tower.totalCost = tower.totalCost + upgradeCost
        
        showTowerMenu_ = false
        print("å‡çº§ " .. config.name .. " åˆ° " .. tower.level .. " çº§")
        return true
    else
        print("é‡‘å¸ä¸è¶³ï¼")
        return false
    end
end

function SellTower(tower, spot)
    -- åº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼šå‡ºå”®è¿”è¿˜æ¯”ä¾‹
    local sellBonus = GetSkillEffect("sell_refund")
    local refundRate = CONFIG.SellRefundRate + sellBonus
    local refund = math.floor(tower.totalCost * refundRate)
    playerGold_ = playerGold_ + refund
    
    -- ä»towers_åˆ—è¡¨ç§»é™¤
    for i, t in ipairs(towers_) do
        if t == tower then
            table.remove(towers_, i)
            break
        end
    end
    
    spot.tower = nil
    showTowerMenu_ = false
    print("å‡ºå”®å¡”ï¼Œè¿”è¿˜ " .. refund .. " é‡‘å¸")
end

-- ============================================================================
-- 9. äº‹ä»¶å¤„ç†
-- ============================================================================

---@param eventType string
---@param eventData UpdateEventData
function HandleUpdate(eventType, eventData)
    local dt = eventData["TimeStep"]:GetFloat()
    
    if currentState_ == GameState.PLAYING then
        gameTime_ = gameTime_ + dt
        
        -- æ›´æ–°æ³¢æ¬¡ç”Ÿæˆ
        if waveActive_ then
            spawnTimer_ = spawnTimer_ + dt
            
            -- ç”Ÿæˆæ•Œäºº
            for i = #waveEnemyQueue_, 1, -1 do
                if waveEnemyQueue_[i].delay <= spawnTimer_ then
                    SpawnEnemy(waveEnemyQueue_[i].type)
                    table.remove(waveEnemyQueue_, i)
                end
            end
            
            -- æ³¢æ¬¡ç»“æŸæ£€æŸ¥
            if #waveEnemyQueue_ == 0 and #enemies_ == 0 then
                waveActive_ = false
                waveTimer_ = 0
                
                -- æ³¢æ¬¡å¥–åŠ±ï¼ˆåº”ç”¨æŠ€èƒ½æ ‘åŠ æˆï¼‰
                local waveBonusFlat = GetSkillEffect("wave_bonus_flat")
                local waveBonusPercent = GetSkillEffect("wave_bonus")  -- å¯èƒ½æ˜¯è´Ÿæ•°ï¼ˆè´·æ¬¾debuffï¼‰
                local waveReward = math.floor((CONFIG.WaveBonus + waveBonusFlat) * (1 + waveBonusPercent))
                playerGold_ = playerGold_ + waveReward
                totalGoldEarned_ = totalGoldEarned_ + waveReward
                
                -- æŠ€èƒ½æ ‘åŠ æˆï¼šæ¯æ³¢æ¢å¤ç”Ÿå‘½
                local lifeRegen = GetSkillEffect("life_regen_wave")
                if lifeRegen > 0 then
                    local maxLives = CONFIG.InitialLives + GetSkillEffect("max_lives")
                    playerLives_ = math.min(playerLives_ + lifeRegen, maxLives)
                end
                
                print("æ³¢æ¬¡ " .. currentWave_ .. " å®Œæˆï¼å¥–åŠ± " .. waveReward .. " é‡‘å¸")
            end
        else
            -- ç­‰å¾…ä¸‹ä¸€æ³¢
            waveTimer_ = waveTimer_ + dt
            if waveTimer_ >= waveDelay_ then
                StartNextWave()
            end
        end
        
        UpdateEnemies(dt)
        UpdateTowers(dt)
        UpdateProjectiles(dt)
        UpdateParticles(dt)
        UpdateScreenShake(dt)
    end
end

-- æ›´æ–°å±å¹•éœ‡åŠ¨æ•ˆæœ
function UpdateScreenShake(dt)
    if screenShake_.timer > 0 then
        screenShake_.timer = screenShake_.timer - dt
        -- è®¡ç®—éšæœºéœ‡åŠ¨åç§»ï¼Œå¼ºåº¦éšæ—¶é—´è¡°å‡
        local ratio = screenShake_.timer / 0.5  -- å‡è®¾æœ€å¤§æŒç»­æ—¶é—´0.5ç§’
        local intensity = screenShake_.intensity * ratio
        screenShake_.offsetX = (math.random() - 0.5) * 2 * intensity
        screenShake_.offsetY = (math.random() - 0.5) * 2 * intensity
    else
        screenShake_.offsetX = 0
        screenShake_.offsetY = 0
    end
end

-- è§¦å‘å±å¹•éœ‡åŠ¨
function TriggerScreenShake(intensity, duration)
    intensity = intensity or 10
    duration = duration or 0.3
    -- å¦‚æœæ–°çš„éœ‡åŠ¨æ›´å¼ºï¼Œåˆ™è¦†ç›–
    if intensity >= screenShake_.intensity or screenShake_.timer <= 0 then
        screenShake_.intensity = intensity
        screenShake_.timer = duration
    end
end

---@param eventType string
---@param eventData MouseButtonDownEventData
function HandleMouseDown(eventType, eventData)
    local button = eventData["Button"]:GetInt()
    local mx = input.mousePosition.x
    local my = input.mousePosition.y
    
    if button == MOUSEB_LEFT then
        if currentState_ == GameState.MENU then
            HandleMenuClick(mx, my)
        elseif currentState_ == GameState.PLAYING then
            HandleGameClick(mx, my)
        elseif currentState_ == GameState.VICTORY or currentState_ == GameState.DEFEAT then
            HandleEndClick(mx, my)
        end
    elseif button == MOUSEB_RIGHT then
        -- å³é”®å–æ¶ˆ
        showTowerMenu_ = false
        selectedTowerSpot_ = nil
    end
end

function HandleMenuClick(mx, my)
    local width = graphics.width
    local height = graphics.height
    
    -- å¦‚æœå…³å¡é€‰æ‹©é¢æ¿æ‰“å¼€ï¼Œä¼˜å…ˆå¤„ç†é¢æ¿ç‚¹å‡»
    if showLevelSelectPanel_ then
        HandleLevelSelectPanelClick(mx, my)
        return
    end
    
    -- åº•éƒ¨æŒ‰é’®åŒºåŸŸï¼ˆä¸ DrawMenu ä¸€è‡´ï¼šheight - 200ï¼‰
    local bottomBarY = height - 200
    
    -- å…ˆæ£€æŸ¥æ˜¯å¦åœ¨åº•éƒ¨åŒºåŸŸ
    if my >= bottomBarY then
        -- æ£€æŸ¥"é‡ç½®æŠ€èƒ½"æŒ‰é’®ç‚¹å‡»
        local resetBtnWidth = 120
        local resetBtnHeight = 40
        local resetBtnX = 30
        local resetBtnY = bottomBarY + 50
        
        if mx >= resetBtnX and mx <= resetBtnX + resetBtnWidth and
           my >= resetBtnY and my <= resetBtnY + resetBtnHeight then
            ResetAllSkills()
            return
        end
        
        -- æ£€æŸ¥"è¿›å…¥æˆ˜æ–—"æŒ‰é’®ç‚¹å‡»
        local battleBtnWidth = 280
        local battleBtnX = (width - battleBtnWidth) / 2
        local battleBtnY = bottomBarY + 40
        local battleBtnHeight = 60
        
        if mx >= battleBtnX and mx <= battleBtnX + battleBtnWidth and
           my >= battleBtnY and my <= battleBtnY + battleBtnHeight then
            showLevelSelectPanel_ = true
            return
        end
        
        return  -- åº•éƒ¨åŒºåŸŸä½†ä¸åœ¨æŒ‰é’®ä¸Šï¼Œä¸å¤„ç†
    end
    
    -- æ£€æŸ¥æŠ€èƒ½èŠ‚ç‚¹ç‚¹å‡»ï¼ˆåœ¨åº•éƒ¨æŒ‰é’®åŒºåŸŸä¹‹ä¸Šï¼‰
    HandleMenuSkillClick(mx, my)
end

-- å¤„ç†ä¸»èœå•ä¸­æŠ€èƒ½èŠ‚ç‚¹çš„ç‚¹å‡»
function HandleMenuSkillClick(mx, my)
    local width = graphics.width
    local height = graphics.height
    
    local lineCount = #SkillTreeLayout.lineOrder
    local lineWidth = (width - 100) / lineCount
    local startY = 120
    local skillNodeHeight = 65
    local skillGap = 12
    
    for lineIdx, lineId in ipairs(SkillTreeLayout.lineOrder) do
        local line = SkillTree[lineId]
        local lineX = 50 + (lineIdx - 1) * lineWidth + lineWidth / 2
        local nodeWidth = lineWidth - 30
        local nodeX = lineX - nodeWidth / 2
        
        local orderedSkills = GetOrderedSkills(lineId)
        
        for skillIdx, skillId in ipairs(orderedSkills) do
            local nodeY = startY + 35 + (skillIdx - 1) * (skillNodeHeight + skillGap)
            
            if mx >= nodeX and mx <= nodeX + nodeWidth and
               my >= nodeY and my <= nodeY + skillNodeHeight then
                local success, errMsg = UpgradeSkill(lineId, skillId)
                if success then
                    print("æˆåŠŸå‡çº§æŠ€èƒ½: " .. line.skills[skillId].name)
                else
                    print("æ— æ³•å‡çº§: " .. (errMsg or "æœªçŸ¥åŸå› "))
                end
                return
            end
        end
    end
end

-- å¤„ç†å…³å¡é€‰æ‹©é¢æ¿ç‚¹å‡»
function HandleLevelSelectPanelClick(mx, my)
    local width = graphics.width
    local height = graphics.height
    
    -- é¢æ¿å°ºå¯¸
    local panelWidth = 500
    local panelHeight = 500
    local panelX = (width - panelWidth) / 2
    local panelY = (height - panelHeight) / 2
    
    -- æ£€æŸ¥å…³é—­æŒ‰é’®
    local closeBtnSize = 40
    local closeBtnX = panelX + panelWidth - closeBtnSize - 10
    local closeBtnY = panelY + 10
    
    if mx >= closeBtnX and mx <= closeBtnX + closeBtnSize and
       my >= closeBtnY and my <= closeBtnY + closeBtnSize then
        showLevelSelectPanel_ = false
        return
    end
    
    -- æ£€æŸ¥å…³å¡æŒ‰é’®
    local buttonWidth = 420
    local buttonHeight = 75
    local buttonStartY = panelY + 90
    local buttonGap = 15
    
    for i = 1, 4 do
        local bx = panelX + (panelWidth - buttonWidth) / 2
        local by = buttonStartY + (i - 1) * (buttonHeight + buttonGap)
        
        if mx >= bx and mx <= bx + buttonWidth and my >= by and my <= by + buttonHeight then
            showLevelSelectPanel_ = false
            StartLevel(i)
            return
        end
    end
    
    -- ç‚¹å‡»é¢æ¿å¤–éƒ¨å…³é—­é¢æ¿
    if mx < panelX or mx > panelX + panelWidth or my < panelY or my > panelY + panelHeight then
        showLevelSelectPanel_ = false
        return
    end
end

function HandleGameClick(mx, my)
    local level = Levels[selectedLevel_]
    local width = graphics.width
    local height = graphics.height
    
    -- æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†"é€€å‡º"æŒ‰é’®ï¼ˆå³ä¸Šè§’ï¼‰
    local exitBtnWidth = 100
    local exitBtnHeight = 40
    local exitBtnX = width - exitBtnWidth - 20
    local exitBtnY = 10
    
    if mx >= exitBtnX and mx <= exitBtnX + exitBtnWidth and my >= exitBtnY and my <= exitBtnY + exitBtnHeight then
        -- è¿”å›ä¸»èœå•
        currentState_ = GameState.MENU
        showTowerMenu_ = false
        selectedTowerSpot_ = nil
        return
    end
    
    -- æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†"ä¸‹ä¸€æ³¢"æŒ‰é’®
    local buttonWidth = 180
    local buttonHeight = 60
    local bx = width - buttonWidth - 30
    local by = height - buttonHeight - 30
    
    if mx >= bx and mx <= bx + buttonWidth and my >= by and my <= by + buttonHeight then
        TriggerNextWave()
        return
    end
    
    -- æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å¡”èœå•
    if showTowerMenu_ and menuTower_ then
        local menuHandled = HandleTowerMenuClick(mx, my)
        if menuHandled then
            return
        end
    end
    
    -- æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æ”¾ç½®ç‚¹
    for _, spot in ipairs(level.towerSpots) do
        local dist = math.sqrt((mx - spot.x)^2 + (my - spot.y)^2)
        if dist <= CONFIG.GridSize / 2 then
            selectedTowerSpot_ = spot
            showTowerMenu_ = true
            menuTower_ = spot
            return
        end
    end
    
    -- ç‚¹å‡»ç©ºç™½å¤„å…³é—­èœå•
    showTowerMenu_ = false
    selectedTowerSpot_ = nil
end

-- è§¦å‘ä¸‹ä¸€æ³¢
function TriggerNextWave()
    local level = Levels[selectedLevel_]
    if not waveActive_ and currentWave_ < #level.waves then
        waveTimer_ = waveDelay_  -- ç«‹å³è§¦å‘ä¸‹ä¸€æ³¢
    end
end

function HandleTowerMenuClick(mx, my)
    local spot = menuTower_
    if not spot then return false end
    
    local menuX = spot.x + 60
    local menuY = spot.y - 100
    local buttonWidth = 160
    local buttonHeight = 48
    
    if spot.tower then
        -- å·²æœ‰å¡”ï¼šå‡çº§/å‡ºå”®
        -- å‡çº§æŒ‰é’®
        if mx >= menuX and mx <= menuX + buttonWidth and my >= menuY and my <= menuY + buttonHeight then
            UpgradeTower(spot.tower)
            return true
        end
        -- å‡ºå”®æŒ‰é’®
        menuY = menuY + 58
        if mx >= menuX and mx <= menuX + buttonWidth and my >= menuY and my <= menuY + buttonHeight then
            SellTower(spot.tower, spot)
            return true
        end
    else
        -- ç©ºåœ°ï¼šé€‰æ‹©å¡”ç±»å‹
        local towerTypes = {"arrow", "cannon", "slow", "laser"}
        for i, ttype in ipairs(towerTypes) do
            local by = menuY + (i - 1) * 58
            if mx >= menuX and mx <= menuX + buttonWidth and my >= by and my <= by + buttonHeight then
                BuildTower(spot, ttype)
                return true
            end
        end
    end
    
    return false
end

function HandleEndClick(mx, my)
    local width = graphics.width
    local height = graphics.height
    
    -- é‡æ–°å¼€å§‹æŒ‰é’®
    local buttonWidth = 220
    local buttonHeight = 60
    local bx = (width - buttonWidth) / 2
    local by = height / 2 + 120
    
    if mx >= bx and mx <= bx + buttonWidth and my >= by and my <= by + buttonHeight then
        StartLevel(selectedLevel_)
        return
    end
    
    -- è¿”å›èœå•æŒ‰é’®
    by = by + 80
    if mx >= bx and mx <= bx + buttonWidth and my >= by and my <= by + buttonHeight then
        currentState_ = GameState.MENU
        return
    end
end

---@param eventType string
---@param eventData KeyDownEventData
function HandleKeyDown(eventType, eventData)
    local key = eventData["Key"]:GetInt()
    
    if key == KEY_ESCAPE then
        if currentState_ == GameState.MENU and showLevelSelectPanel_ then
            -- å…³é—­å…³å¡é€‰æ‹©é¢æ¿
            showLevelSelectPanel_ = false
        elseif currentState_ == GameState.PLAYING then
            currentState_ = GameState.MENU
        else
            engine:Exit()
        end
    elseif key == KEY_SPACE then
        if currentState_ == GameState.PLAYING then
            TriggerNextWave()
        end
    end
end

-- ============================================================================
-- 10. æ¸²æŸ“å‡½æ•°
-- ============================================================================

function HandleRender(eventType, eventData)
    if nvg_ == nil then return end
    
    local width = graphics.width
    local height = graphics.height
    
    nvgBeginFrame(nvg_, width, height, 1.0)
    
    if currentState_ == GameState.MENU then
        DrawMenu(width, height)
    elseif currentState_ == GameState.PLAYING then
        DrawGame(width, height)
    elseif currentState_ == GameState.VICTORY then
        DrawEndScreen(width, height, true)
    elseif currentState_ == GameState.DEFEAT then
        DrawEndScreen(width, height, false)
    end
    
    nvgEndFrame(nvg_)
end

function DrawMenu(width, height)
    -- èƒŒæ™¯ï¼ˆæ·±ç´«è‰²æ¸å˜ï¼Œä¸æŠ€èƒ½æ ‘é£æ ¼ä¸€è‡´ï¼‰
    local bg = nvgLinearGradient(nvg_, 0, 0, 0, height,
        nvgRGBA(35, 25, 55, 255),
        nvgRGBA(20, 15, 35, 255))
    nvgBeginPath(nvg_)
    nvgRect(nvg_, 0, 0, width, height)
    nvgFillPaint(nvg_, bg)
    nvgFill(nvg_)
    
    -- æ ‡é¢˜
    nvgFontFace(nvg_, "sans")
    nvgFontSize(nvg_, 56)
    nvgFillColor(nvg_, nvgRGBA(200, 150, 255, 255))
    nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
    nvgText(nvg_, width / 2, 45, "â­ å¡”é˜²æ¸¸æˆ - æŠ€èƒ½æ ‘", nil)
    
    -- æŠ€èƒ½ç‚¹æ˜¾ç¤º
    nvgFontSize(nvg_, 24)
    nvgFillColor(nvg_, nvgRGBA(255, 220, 100, 255))
    nvgText(nvg_, width / 2, 85, "å¯ç”¨æŠ€èƒ½ç‚¹: " .. PlayerSkills.skillPoints, nil)
    
    -- è®¡ç®—å¸ƒå±€ï¼ˆåº•éƒ¨ç•™å‡ºç©ºé—´ç»™æŒ‰é’®ï¼‰
    local lineCount = #SkillTreeLayout.lineOrder
    local lineWidth = (width - 100) / lineCount
    local startY = 120
    local skillNodeHeight = 65
    local skillGap = 12
    
    -- ç»˜åˆ¶æ¯æ¡æŠ€èƒ½çº¿
    for lineIdx, lineId in ipairs(SkillTreeLayout.lineOrder) do
        local line = SkillTree[lineId]
        local lineX = 50 + (lineIdx - 1) * lineWidth + lineWidth / 2
        local lineColor = SkillTreeLayout.lineColors[lineId]
        local lineIcon = SkillTreeLayout.lineIcons[lineId]
        
        -- çº¿è·¯æ ‡é¢˜
        nvgFontSize(nvg_, 22)
        nvgFillColor(nvg_, nvgRGBA(lineColor[1], lineColor[2], lineColor[3], 255))
        nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
        nvgText(nvg_, lineX, startY, lineIcon .. " " .. line.name, nil)
        
        -- æŒ‰ç…§ä¾èµ–é¡ºåºæ’åˆ—æŠ€èƒ½
        local orderedSkills = GetOrderedSkills(lineId)
        
        -- ç»˜åˆ¶æ¯ä¸ªæŠ€èƒ½èŠ‚ç‚¹
        for skillIdx, skillId in ipairs(orderedSkills) do
            local skill = line.skills[skillId]
            local nodeY = startY + 35 + (skillIdx - 1) * (skillNodeHeight + skillGap)
            local nodeWidth = lineWidth - 30
            local nodeX = lineX - nodeWidth / 2
            
            local currentLevel = GetSkillLevel(skillId)
            local canUpgrade, _ = CanUpgradeSkill(lineId, skillId)
            
            -- èŠ‚ç‚¹èƒŒæ™¯
            local alpha = 200
            if currentLevel > 0 then
                -- å·²å­¦ä¹ ï¼šé«˜äº®
                nvgBeginPath(nvg_)
                nvgRoundedRect(nvg_, nodeX, nodeY, nodeWidth, skillNodeHeight, 8)
                nvgFillColor(nvg_, nvgRGBA(lineColor[1], lineColor[2], lineColor[3], alpha))
                nvgFill(nvg_)
            elseif canUpgrade then
                -- å¯å­¦ä¹ ï¼šåŠé€æ˜
                nvgBeginPath(nvg_)
                nvgRoundedRect(nvg_, nodeX, nodeY, nodeWidth, skillNodeHeight, 8)
                nvgFillColor(nvg_, nvgRGBA(lineColor[1] / 2, lineColor[2] / 2, lineColor[3] / 2, alpha))
                nvgFill(nvg_)
                -- å‘å…‰è¾¹æ¡†è¡¨ç¤ºå¯ç‚¹å‡»
                nvgStrokeColor(nvg_, nvgRGBA(255, 255, 100, 180))
                nvgStrokeWidth(nvg_, 2)
                nvgStroke(nvg_)
            else
                -- é”å®šï¼šæš—è‰²
                nvgBeginPath(nvg_)
                nvgRoundedRect(nvg_, nodeX, nodeY, nodeWidth, skillNodeHeight, 8)
                nvgFillColor(nvg_, nvgRGBA(60, 60, 70, alpha))
                nvgFill(nvg_)
            end
            
            -- è¾¹æ¡†
            nvgBeginPath(nvg_)
            nvgRoundedRect(nvg_, nodeX, nodeY, nodeWidth, skillNodeHeight, 8)
            nvgStrokeColor(nvg_, nvgRGBA(lineColor[1], lineColor[2], lineColor[3], 150))
            nvgStrokeWidth(nvg_, 1)
            nvgStroke(nvg_)
            
            -- æŠ€èƒ½åç§°
            nvgFontSize(nvg_, 18)
            nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
            nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
            nvgText(nvg_, lineX, nodeY + 15, skill.name, nil)
            
            -- ç­‰çº§æ˜¾ç¤º
            nvgFontSize(nvg_, 14)
            if currentLevel >= skill.maxLevel then
                nvgFillColor(nvg_, nvgRGBA(100, 255, 100, 255))
                nvgText(nvg_, lineX, nodeY + 32, "å·²æ»¡çº§ (" .. currentLevel .. "/" .. skill.maxLevel .. ")", nil)
            else
                nvgFillColor(nvg_, nvgRGBA(200, 200, 200, 255))
                local costText = ""
                if currentLevel < skill.maxLevel then
                    costText = " èŠ±è´¹: " .. skill.costs[currentLevel + 1]
                end
                nvgText(nvg_, lineX, nodeY + 32, currentLevel .. "/" .. skill.maxLevel .. costText, nil)
            end
            
            -- æè¿°
            nvgFontSize(nvg_, 13)
            nvgFillColor(nvg_, nvgRGBA(200, 200, 200, 220))
            nvgText(nvg_, lineX, nodeY + 50, skill.description, nil)
        end
    end
    
    -- åº•éƒ¨æŒ‰é’®åŒºåŸŸèƒŒæ™¯ï¼ˆç§»åŠ¨åˆ°æ›´ä¸Šæ–¹ä»¥æµ‹è¯•ï¼‰
    local bottomBarY = height - 200
    nvgBeginPath(nvg_)
    nvgRect(nvg_, 0, bottomBarY, width, 200)
    nvgFillColor(nvg_, nvgRGBA(25, 20, 40, 200))
    nvgFill(nvg_)
    
    -- åˆ†éš”çº¿
    nvgBeginPath(nvg_)
    nvgMoveTo(nvg_, 0, bottomBarY)
    nvgLineTo(nvg_, width, bottomBarY)
    nvgStrokeColor(nvg_, nvgRGBA(100, 80, 150, 150))
    nvgStrokeWidth(nvg_, 2)
    nvgStroke(nvg_)
    
    -- è¿›å…¥æˆ˜æ–—æŒ‰é’®ï¼ˆå±…ä¸­ï¼Œå¤§æŒ‰é’®ï¼Œç§»åŠ¨åˆ°æ›´ä¸Šæ–¹ï¼‰
    local battleBtnWidth = 280
    local battleBtnHeight = 60
    local battleBtnX = (width - battleBtnWidth) / 2
    local battleBtnY = bottomBarY + 40
    
    -- æŒ‰é’®èƒŒæ™¯ï¼ˆé’è‰²é£æ ¼ï¼‰
    local btnBg = nvgLinearGradient(nvg_, battleBtnX, battleBtnY, battleBtnX, battleBtnY + battleBtnHeight,
        nvgRGBA(62, 213, 170, 230),
        nvgRGBA(45, 160, 130, 230))
    nvgBeginPath(nvg_)
    nvgRoundedRect(nvg_, battleBtnX, battleBtnY, battleBtnWidth, battleBtnHeight, 12)
    nvgFillPaint(nvg_, btnBg)
    nvgFill(nvg_)
    
    -- æŒ‰é’®è¾¹æ¡†
    nvgStrokeColor(nvg_, nvgRGBA(80, 240, 200, 200))
    nvgStrokeWidth(nvg_, 3)
    nvgStroke(nvg_)
    
    -- æŒ‰é’®æ–‡å­—
    nvgFontSize(nvg_, 32)
    nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
    nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
    nvgText(nvg_, battleBtnX + battleBtnWidth / 2, battleBtnY + battleBtnHeight / 2, "âš”ï¸ è¿›å…¥æˆ˜æ–—", nil)
    
    -- é‡ç½®æŠ€èƒ½æŒ‰é’®ï¼ˆå·¦ä¾§ï¼Œä¸è¿›å…¥æˆ˜æ–—æŒ‰é’®åŒä¸€è¡Œï¼‰
    local resetBtnWidth = 120
    local resetBtnHeight = 40
    local resetBtnX = 30
    local resetBtnY = bottomBarY + 50
    
    nvgBeginPath(nvg_)
    nvgRoundedRect(nvg_, resetBtnX, resetBtnY, resetBtnWidth, resetBtnHeight, 8)
    nvgFillColor(nvg_, nvgRGBA(150, 70, 70, 200))
    nvgFill(nvg_)
    nvgStrokeColor(nvg_, nvgRGBA(200, 100, 100, 180))
    nvgStrokeWidth(nvg_, 2)
    nvgStroke(nvg_)
    
    nvgFontSize(nvg_, 18)
    nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
    nvgText(nvg_, resetBtnX + resetBtnWidth / 2, resetBtnY + resetBtnHeight / 2, "ğŸ”„ é‡ç½®æŠ€èƒ½", nil)
    
    -- ç»˜åˆ¶å…³å¡é€‰æ‹©é¢æ¿ï¼ˆå¦‚æœæ‰“å¼€ï¼‰
    if showLevelSelectPanel_ then
        DrawLevelSelectPanel(width, height)
    end
end

-- ç»˜åˆ¶å…³å¡é€‰æ‹©é¢æ¿
function DrawLevelSelectPanel(width, height)
    -- åŠé€æ˜é®ç½©
    nvgBeginPath(nvg_)
    nvgRect(nvg_, 0, 0, width, height)
    nvgFillColor(nvg_, nvgRGBA(0, 0, 0, 180))
    nvgFill(nvg_)
    
    -- é¢æ¿å°ºå¯¸
    local panelWidth = 500
    local panelHeight = 500
    local panelX = (width - panelWidth) / 2
    local panelY = (height - panelHeight) / 2
    
    -- é¢æ¿èƒŒæ™¯
    local panelBg = nvgLinearGradient(nvg_, panelX, panelY, panelX, panelY + panelHeight,
        nvgRGBA(50, 40, 70, 250),
        nvgRGBA(35, 28, 50, 250))
    nvgBeginPath(nvg_)
    nvgRoundedRect(nvg_, panelX, panelY, panelWidth, panelHeight, 16)
    nvgFillPaint(nvg_, panelBg)
    nvgFill(nvg_)
    
    -- é¢æ¿è¾¹æ¡†
    nvgStrokeColor(nvg_, nvgRGBA(100, 80, 150, 200))
    nvgStrokeWidth(nvg_, 3)
    nvgStroke(nvg_)
    
    -- æ ‡é¢˜
    nvgFontFace(nvg_, "sans")
    nvgFontSize(nvg_, 36)
    nvgFillColor(nvg_, nvgRGBA(62, 213, 170, 255))
    nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
    nvgText(nvg_, panelX + panelWidth / 2, panelY + 45, "âš”ï¸ é€‰æ‹©å…³å¡", nil)
    
    -- å…³å¡æŒ‰é’®
    local buttonWidth = 420
    local buttonHeight = 75
    local buttonStartY = panelY + 90
    local buttonGap = 15
    
    for i = 1, 4 do
        local bx = panelX + (panelWidth - buttonWidth) / 2
        local by = buttonStartY + (i - 1) * (buttonHeight + buttonGap)
        local level = Levels[i]
        
        -- æŒ‰é’®èƒŒæ™¯æ¸å˜
        local btnBg = nvgLinearGradient(nvg_, bx, by, bx, by + buttonHeight,
            nvgRGBA(62, 213, 170, 180),
            nvgRGBA(45, 160, 130, 180))
        nvgBeginPath(nvg_)
        nvgRoundedRect(nvg_, bx, by, buttonWidth, buttonHeight, 12)
        nvgFillPaint(nvg_, btnBg)
        nvgFill(nvg_)
        
        -- æŒ‰é’®è¾¹æ¡†
        nvgStrokeColor(nvg_, nvgRGBA(80, 240, 200, 150))
        nvgStrokeWidth(nvg_, 2)
        nvgStroke(nvg_)
        
        -- å…³å¡åç§°
        nvgFontSize(nvg_, 26)
        nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
        nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
        nvgText(nvg_, bx + buttonWidth / 2, by + buttonHeight / 2 - 10, level.name, nil)
        
        -- å…³å¡æè¿°
        nvgFontSize(nvg_, 16)
        nvgFillColor(nvg_, nvgRGBA(220, 220, 220, 200))
        nvgText(nvg_, bx + buttonWidth / 2, by + buttonHeight / 2 + 14, level.description, nil)
    end
    
    -- å…³é—­æŒ‰é’®ï¼ˆXï¼‰
    local closeBtnSize = 40
    local closeBtnX = panelX + panelWidth - closeBtnSize - 10
    local closeBtnY = panelY + 10
    
    nvgBeginPath(nvg_)
    nvgRoundedRect(nvg_, closeBtnX, closeBtnY, closeBtnSize, closeBtnSize, 8)
    nvgFillColor(nvg_, nvgRGBA(150, 70, 70, 200))
    nvgFill(nvg_)
    
    nvgFontSize(nvg_, 28)
    nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
    nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
    nvgText(nvg_, closeBtnX + closeBtnSize / 2, closeBtnY + closeBtnSize / 2, "âœ•", nil)
    
    -- åº•éƒ¨æç¤º
    nvgFontSize(nvg_, 16)
    nvgFillColor(nvg_, nvgRGBA(150, 150, 150, 200))
    nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_BOTTOM)
    nvgText(nvg_, panelX + panelWidth / 2, panelY + panelHeight - 15, "ç‚¹å‡»é€‰æ‹©å…³å¡å¼€å§‹æ¸¸æˆ | ESCå…³é—­é¢æ¿", nil)
end

-- ============================================================================
-- æŠ€èƒ½æ ‘è¾…åŠ©å‡½æ•°
-- ============================================================================

-- è·å–æ’åºåçš„æŠ€èƒ½åˆ—è¡¨ï¼ˆæŒ‰ä¾èµ–é¡ºåºï¼‰
function GetOrderedSkills(lineId)
    local line = SkillTree[lineId]
    local ordered = {}
    local added = {}
    
    -- å…ˆæ·»åŠ æ²¡æœ‰å‰ç½®çš„æŠ€èƒ½
    for skillId, skill in pairs(line.skills) do
        if not skill.prerequisite then
            table.insert(ordered, skillId)
            added[skillId] = true
        end
    end
    
    -- ç„¶åæŒ‰ä¾èµ–é¡ºåºæ·»åŠ å…¶ä»–æŠ€èƒ½
    local maxIterations = 20
    local iteration = 0
    while iteration < maxIterations do
        iteration = iteration + 1
        local addedAny = false
        for skillId, skill in pairs(line.skills) do
            if not added[skillId] and skill.prerequisite and added[skill.prerequisite] then
                table.insert(ordered, skillId)
                added[skillId] = true
                addedAny = true
            end
        end
        if not addedAny then break end
    end
    
    return ordered
end

function DrawGame(width, height)
    local level = Levels[selectedLevel_]
    
    -- ç»˜åˆ¶æ¸¸æˆåœºæ™¯èƒŒæ™¯ï¼ˆèƒŒæ™¯ä¸éœ‡åŠ¨ï¼‰
    local bgColor = level.backgroundColor
    nvgBeginPath(nvg_)
    nvgRect(nvg_, 0, 0, width, height)
    nvgFillColor(nvg_, nvgRGBA(bgColor[1], bgColor[2], bgColor[3], 255))
    nvgFill(nvg_)
    
    -- åº”ç”¨å±å¹•éœ‡åŠ¨åç§»
    nvgSave(nvg_)
    if screenShake_.timer > 0 then
        nvgTranslate(nvg_, screenShake_.offsetX, screenShake_.offsetY)
    end
    
    -- ç»˜åˆ¶è·¯å¾„
    DrawPath(level.path)
    
    -- ç»˜åˆ¶æ”¾ç½®ç‚¹
    DrawTowerSpots(level.towerSpots)
    
    -- ç»˜åˆ¶å¡”
    DrawTowers()
    
    -- ç»˜åˆ¶æ•Œäºº
    DrawEnemies()
    
    -- ç»˜åˆ¶æ¿€å…‰ï¼ˆåœ¨æ•Œäººä¹‹ä¸Šï¼‰
    DrawLasers()
    
    -- ç»˜åˆ¶å­å¼¹
    DrawProjectiles()
    
    -- ç»˜åˆ¶ç²’å­
    DrawParticles()
    
    -- ç»˜åˆ¶å¡”èœå•
    if showTowerMenu_ and menuTower_ then
        DrawTowerMenu(menuTower_)
    end
    
    -- æ¢å¤å˜æ¢ï¼ˆHUDä¸éœ‡åŠ¨ï¼‰
    nvgRestore(nvg_)
    
    -- ç»˜åˆ¶HUD
    DrawHUD(width, height)
    
    -- å¦‚æœæ­£åœ¨éœ‡åŠ¨ï¼Œç»˜åˆ¶çº¢è‰²é—ªçƒè¾¹æ¡†æ•ˆæœ
    if screenShake_.timer > 0 then
        local alpha = math.floor(80 * (screenShake_.timer / 0.3))
        nvgBeginPath(nvg_)
        nvgRect(nvg_, 0, 0, width, height)
        nvgStrokeColor(nvg_, nvgRGBA(255, 50, 50, alpha))
        nvgStrokeWidth(nvg_, 8)
        nvgStroke(nvg_)
    end
end

-- æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨é“è·¯åŒºåŸŸå†…ï¼ˆåŒ…æ‹¬æŠ¤æ ï¼‰
function IsPointInPathArea(px, py, path, checkWidth, excludeSegment)
    local halfWidth = checkWidth / 2
    for i = 1, #path - 1 do
        if i ~= excludeSegment then
            local x1, y1 = path[i].x, path[i].y
            local x2, y2 = path[i + 1].x, path[i + 1].y
            
            local dx = x2 - x1
            local dy = y2 - y1
            local len = math.sqrt(dx * dx + dy * dy)
            if len > 0 then
                local t = math.max(0, math.min(1, ((px - x1) * dx + (py - y1) * dy) / (len * len)))
                local closestX = x1 + t * dx
                local closestY = y1 + t * dy
                local distSq = (px - closestX)^2 + (py - closestY)^2
                if distSq < halfWidth * halfWidth then
                    return true
                end
            end
        end
    end
    return false
end

-- æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨é“è·¯çº¿æ®µå†…éƒ¨
function IsPointNearSegment(px, py, x1, y1, x2, y2, width)
    local dx = x2 - x1
    local dy = y2 - y1
    local len = math.sqrt(dx * dx + dy * dy)
    if len == 0 then return false end
    
    local t = math.max(0, math.min(1, ((px - x1) * dx + (py - y1) * dy) / (len * len)))
    local closestX = x1 + t * dx
    local closestY = y1 + t * dy
    local distSq = (px - closestX)^2 + (py - closestY)^2
    return distSq < (width / 2)^2
end

-- åˆ‡å‰²çŸ©å½¢ï¼šå¦‚æœçŸ©å½¢è¢«é“è·¯åˆ†å‰²ï¼Œè¿”å›åˆ‡å‰²åçš„çŸ©å½¢åˆ—è¡¨
function SplitRectByPath(rect, path, pathWidth)
    local result = {}
    local p1, p2, p3, p4 = rect.p1, rect.p2, rect.p3, rect.p4
    
    -- è®¡ç®—çŸ©å½¢çš„ä¸­å¿ƒçº¿ä¸Šå¤šä¸ªé‡‡æ ·ç‚¹
    local samplePoints = {}
    for t = 0, 1, 0.1 do
        local mx = p1.x * (1-t) + p2.x * t
        local my = p1.y * (1-t) + p2.y * t
        local mx2 = p4.x * (1-t) + p3.x * t
        local my2 = p4.y * (1-t) + p3.y * t
        table.insert(samplePoints, {
            t = t,
            inner = {x = mx, y = my},
            outer = {x = mx2, y = my2},
            center = {x = (mx + mx2) / 2, y = (my + my2) / 2}
        })
    end
    
    -- æ£€æŸ¥æ¯ä¸ªé‡‡æ ·ç‚¹æ˜¯å¦è¢«é“è·¯é®æŒ¡
    local segments = {}
    local currentSegment = nil
    
    for _, sample in ipairs(samplePoints) do
        local isBlocked = false
        for j = 1, #path - 1 do
            if j ~= rect.segmentIndex then
                if IsPointNearSegment(sample.center.x, sample.center.y, 
                    path[j].x, path[j].y, path[j+1].x, path[j+1].y, pathWidth + 20) then
                    isBlocked = true
                    break
                end
            end
        end
        
        if not isBlocked then
            if not currentSegment then
                currentSegment = {startT = sample.t, endT = sample.t}
            else
                currentSegment.endT = sample.t
            end
        else
            if currentSegment then
                table.insert(segments, currentSegment)
                currentSegment = nil
            end
        end
    end
    
    if currentSegment then
        table.insert(segments, currentSegment)
    end
    
    -- æ ¹æ®åˆ†æ®µåˆ›å»ºå­çŸ©å½¢
    for _, seg in ipairs(segments) do
        local t1, t2 = seg.startT, seg.endT
        local subRect = {
            segmentIndex = rect.segmentIndex,
            p1 = { x = p1.x * (1-t1) + p2.x * t1, y = p1.y * (1-t1) + p2.y * t1 },
            p2 = { x = p1.x * (1-t2) + p2.x * t2, y = p1.y * (1-t2) + p2.y * t2 },
            p3 = { x = p4.x * (1-t2) + p3.x * t2, y = p4.y * (1-t2) + p3.y * t2 },
            p4 = { x = p4.x * (1-t1) + p3.x * t1, y = p4.y * (1-t1) + p3.y * t1 },
        }
        subRect.centerX = (subRect.p1.x + subRect.p2.x + subRect.p3.x + subRect.p4.x) / 4
        subRect.centerY = (subRect.p1.y + subRect.p2.y + subRect.p3.y + subRect.p4.y) / 4
        table.insert(result, subRect)
    end
    
    return result
end

function DrawPath(path)
    if #path < 2 then return end
    
    local pathWidth = 100       -- é“è·¯å†…éƒ¨å®½åº¦
    local railWidth = 100       -- æŠ¤æ å®½åº¦ï¼ˆä¸Šä¸‹å·¦å³éƒ½æ˜¯è¿™ä¸ªå®½åº¦ï¼‰
    local shadowOffset = 5     -- é˜´å½±åç§»
    local halfPath = pathWidth / 2
    
    -- æ”¶é›†æ‰€æœ‰8æ–¹å‘çš„çŸ©å½¢
    local allRects = {}
    
    -- å…ˆæ”¶é›†æ‰€æœ‰é“è·¯çš„è¾¹ç•Œæ¡†
    local roadBounds = {}
    for i = 1, #path - 1 do
        local x1, y1 = path[i].x, path[i].y
        local x2, y2 = path[i + 1].x, path[i + 1].y
        table.insert(roadBounds, {
            x_min = math.min(x1, x2) - halfPath,
            x_max = math.max(x1, x2) + halfPath,
            y_min = math.min(y1, y2) - halfPath,
            y_max = math.max(y1, y2) + halfPath,
            segmentIndex = i,
        })
    end
    
    -- åˆ‡å‰²çŸ©å½¢çš„å‡½æ•°ï¼šå¦‚æœçŸ©å½¢è¢«é“è·¯åˆ‡å‰²ï¼Œè¿”å›åˆ‡å‰²åçš„çŸ©å½¢åˆ—è¡¨
    local function splitRectByRoads(rect, excludeSegment)
        local results = {rect}
        
        for _, road in ipairs(roadBounds) do
            if road.segmentIndex ~= excludeSegment then
                local newResults = {}
                
                for _, r in ipairs(results) do
                    -- æ£€æŸ¥çŸ©å½¢ræ˜¯å¦ä¸é“è·¯roadç›¸äº¤
                    local intersectX = not (r.x_max <= road.x_min or r.x_min >= road.x_max)
                    local intersectY = not (r.y_max <= road.y_min or r.y_min >= road.y_max)
                    
                    if intersectX and intersectY then
                        -- æœ‰ç›¸äº¤ï¼Œéœ€è¦åˆ‡å‰²
                        -- è®¡ç®—åˆ‡å‰²åçš„çŸ©å½¢ï¼ˆæ°´å¹³åˆ‡å‰²æˆ–å‚ç›´åˆ‡å‰²ï¼‰
                        
                        -- æ°´å¹³åˆ‡å‰²ï¼ˆä¸Šä¸‹åˆ†å‰²ï¼‰
                        if road.x_min <= r.x_min and road.x_max >= r.x_max then
                            -- é“è·¯å®Œå…¨è¦†ç›–çŸ©å½¢çš„XèŒƒå›´ï¼Œè¿›è¡ŒYæ–¹å‘åˆ‡å‰²
                            -- ä¸Šæ–¹éƒ¨åˆ†
                            if r.y_min < road.y_min then
                                table.insert(newResults, {
                                    x_min = r.x_min, x_max = r.x_max,
                                    y_min = r.y_min, y_max = math.min(r.y_max, road.y_min),
                                    segmentIndex = r.segmentIndex,
                                })
                            end
                            -- ä¸‹æ–¹éƒ¨åˆ†
                            if r.y_max > road.y_max then
                                table.insert(newResults, {
                                    x_min = r.x_min, x_max = r.x_max,
                                    y_min = math.max(r.y_min, road.y_max), y_max = r.y_max,
                                    segmentIndex = r.segmentIndex,
                                })
                            end
                        -- å‚ç›´åˆ‡å‰²ï¼ˆå·¦å³åˆ†å‰²ï¼‰
                        elseif road.y_min <= r.y_min and road.y_max >= r.y_max then
                            -- é“è·¯å®Œå…¨è¦†ç›–çŸ©å½¢çš„YèŒƒå›´ï¼Œè¿›è¡ŒXæ–¹å‘åˆ‡å‰²
                            -- å·¦è¾¹éƒ¨åˆ†
                            if r.x_min < road.x_min then
                                table.insert(newResults, {
                                    x_min = r.x_min, x_max = math.min(r.x_max, road.x_min),
                                    y_min = r.y_min, y_max = r.y_max,
                                    segmentIndex = r.segmentIndex,
                                })
                            end
                            -- å³è¾¹éƒ¨åˆ†
                            if r.x_max > road.x_max then
                                table.insert(newResults, {
                                    x_min = math.max(r.x_min, road.x_max), x_max = r.x_max,
                                    y_min = r.y_min, y_max = r.y_max,
                                    segmentIndex = r.segmentIndex,
                                })
                            end
                        else
                            -- éƒ¨åˆ†ç›¸äº¤ä½†ä¸å®Œå…¨è¦†ç›–ï¼Œä¿ç•™åŸçŸ©å½¢ï¼ˆæˆ–å¯ä»¥æ›´å¤æ‚å¤„ç†ï¼‰
                            -- ç®€åŒ–å¤„ç†ï¼šå¦‚æœä¸­å¿ƒç‚¹åœ¨é“è·¯å†…ï¼Œåˆ™åˆ é™¤æ•´ä¸ªçŸ©å½¢
                            local centerX = (r.x_min + r.x_max) / 2
                            local centerY = (r.y_min + r.y_max) / 2
                            if not (centerX >= road.x_min and centerX <= road.x_max and
                                    centerY >= road.y_min and centerY <= road.y_max) then
                                table.insert(newResults, r)
                            end
                        end
                    else
                        -- æ— ç›¸äº¤ï¼Œä¿ç•™åŸçŸ©å½¢
                        table.insert(newResults, r)
                    end
                end
                
                results = newResults
            end
        end
        
        return results
    end
    
    for i = 1, #path - 1 do
        -- è·å–å½“å‰è·¯å¾„æ®µçš„èµ·ç‚¹å’Œç»ˆç‚¹åæ ‡
        local x1, y1 = path[i].x, path[i].y      -- èµ·ç‚¹
        local x2, y2 = path[i + 1].x, path[i + 1].y  -- ç»ˆç‚¹
        local road_x_min = math.min(x1, x2) - halfPath
        local road_x_max = math.max(x1, x2) + halfPath
        local road_y_min = math.min(y1, y2) - halfPath
        local road_y_max = math.max(y1, y2) + halfPath
        
        -- å®šä¹‰4ä¸ªæ–¹å‘çš„æŠ¤æ çŸ©å½¢
        local railRects = {
            -- ä¸Šä¾§çŸ©å½¢
            { x_min = road_x_min - railWidth, x_max = road_x_max + railWidth,
              y_min = road_y_max, y_max = road_y_max + railWidth, segmentIndex = i },
            -- ä¸‹ä¾§çŸ©å½¢
            { x_min = road_x_min - railWidth, x_max = road_x_max + railWidth,
              y_min = road_y_min - railWidth, y_max = road_y_min, segmentIndex = i },
            -- å·¦ä¾§çŸ©å½¢
            { x_min = road_x_min - railWidth, x_max = road_x_min,
              y_min = road_y_min - railWidth, y_max = road_y_max + railWidth, segmentIndex = i },
            -- å³ä¾§çŸ©å½¢
            { x_min = road_x_max, x_max = road_x_max + railWidth,
              y_min = road_y_min - railWidth, y_max = road_y_max + railWidth, segmentIndex = i },
        }
        
        -- å¯¹æ¯ä¸ªæŠ¤æ çŸ©å½¢è¿›è¡Œåˆ‡å‰²å¤„ç†
        for _, rail in ipairs(railRects) do
            local splitResults = splitRectByRoads(rail, i)
            for _, splitRect in ipairs(splitResults) do
                -- åªæ·»åŠ æœ‰æ•ˆçŸ©å½¢ï¼ˆå®½åº¦å’Œé«˜åº¦éƒ½å¤§äº0ï¼‰
                if splitRect.x_max > splitRect.x_min and splitRect.y_max > splitRect.y_min then
                    table.insert(allRects, splitRect)
                end
            end
        end
    end
    
    -- è®¡ç®—æ¯ä¸ªçŸ©å½¢çš„ä¸­å¿ƒç‚¹å’Œy_minï¼ˆç”¨äºæ’åºï¼‰
    for _, rect in ipairs(allRects) do
        rect.centerX = (rect.x_min + rect.x_max) / 2
        rect.centerY = (rect.y_min + rect.y_max) / 2
        -- è®¡ç®—çŸ©å½¢çš„y_minï¼ˆå››ä¸ªé¡¶ç‚¹ä¸­æœ€å°çš„yå€¼ï¼‰
        rect.sort_value = rect.y_max
    end
    
    -- å¯¹ allRects æŒ‰ y_min æ’åºï¼ˆy_min è¶Šå¤§è¶Šé å‰ï¼Œè¿™æ ·å…ˆç»˜åˆ¶yå°çš„ï¼Œåç»˜åˆ¶yå¤§çš„ï¼‰
    table.sort(allRects, function(a, b)
        return a.sort_value < b.sort_value
    end)
	
    -- ========== ç»˜åˆ¶æ‰€æœ‰æŠ¤æ çŸ©å½¢ ==========
    local liftOffset = 10  -- æŠ¤æ å‘ä¸Šåç§»é‡
    local cornerRadius = 10  -- åœ†è§’åŠå¾„
    
    for _, rect in ipairs(allRects) do
        local width = rect.x_max - rect.x_min
        local height = rect.y_max - rect.y_min
        
        -- 1. å…ˆç»˜åˆ¶ä¸‹æ–¹æ·±é’è‰²éƒ¨åˆ†ï¼ˆ10åƒç´ é«˜åº¦çš„ç«‹ä½“æ•ˆæœï¼‰
        nvgBeginPath(nvg_)
        nvgRoundedRect(nvg_, rect.x_min, rect.y_min + liftOffset, width, height, cornerRadius)
        nvgFillColor(nvg_, nvgRGBA(35, 140, 110, 255))
        nvgFill(nvg_)
    end
    
    for _, rect in ipairs(allRects) do
        local width = rect.x_max - rect.x_min
        local height = rect.y_max - rect.y_min

		-- 2. ç»˜åˆ¶é’è‰²æŠ¤æ 
        nvgBeginPath(nvg_)
        nvgRoundedRect(nvg_, rect.x_min, rect.y_min, width, height, cornerRadius)
        nvgFillColor(nvg_, nvgRGBA(62, 213, 170, 255))
        nvgFill(nvg_)
    end
    
    ---- 3. ç»˜åˆ¶æ·±è‰²é“è·¯å†…éƒ¨
    --for i = 1, #path - 1 do
    --    local x1, y1 = path[i].x, path[i].y
    --    local x2, y2 = path[i + 1].x, path[i + 1].y
    --    
    --    -- è·¯å¾„åªæœ‰æ°´å¹³æˆ–å‚ç›´ä¸¤ç§æƒ…å†µ
    --    local isHorizontal = (y1 == y2)
    --    
    --    nvgBeginPath(nvg_)
    --    if isHorizontal then
    --        -- æ°´å¹³è·¯å¾„ï¼šä¸Šä¸‹åç§»halfPath
    --        nvgMoveTo(nvg_, x1, y1 - halfPath)
    --        nvgLineTo(nvg_, x2, y2 - halfPath)
    --        nvgLineTo(nvg_, x2, y2 + halfPath)
    --        nvgLineTo(nvg_, x1, y1 + halfPath)
    --    else
    --        -- å‚ç›´è·¯å¾„ï¼šå·¦å³åç§»halfPath
    --        nvgMoveTo(nvg_, x1 - halfPath, y1)
    --        nvgLineTo(nvg_, x2 - halfPath, y2)
    --        nvgLineTo(nvg_, x2 + halfPath, y2)
    --        nvgLineTo(nvg_, x1 + halfPath, y1)
    --    end
    --    nvgClosePath(nvg_)
    --    nvgFillColor(nvg_, nvgRGBA(35, 40, 55, 255))
    --    nvgFill(nvg_)
    --end
    
    -- ç»ˆç‚¹æ ‡è®°ï¼ˆæ©™è‰²ç«ç„°å›¾æ ‡ï¼‰
    local endPoint = path[#path]
    DrawEndpointMarker(endPoint.x, endPoint.y)
end

-- ç»˜åˆ¶ç»ˆç‚¹æ ‡è®°ï¼ˆæ©™è‰²ç«ç„°ï¼‰
function DrawEndpointMarker(x, y)
    -- ç«ç„°å¤–å‘å…‰
    local glowGrad = nvgRadialGradient(nvg_, x, y - 10, 0, 30,
        nvgRGBA(255, 180, 50, 80),
        nvgRGBA(255, 100, 0, 0))
    nvgBeginPath(nvg_)
    nvgCircle(nvg_, x, y - 10, 30)
    nvgFillPaint(nvg_, glowGrad)
    nvgFill(nvg_)
    
    -- ç«ç„°ä¸»ä½“
    nvgBeginPath(nvg_)
    nvgMoveTo(nvg_, x, y - 35)  -- é¡¶ç‚¹
    nvgBezierTo(nvg_, x + 8, y - 25, x + 15, y - 15, x + 12, y - 5)
    nvgBezierTo(nvg_, x + 10, y + 5, x + 5, y + 10, x, y + 8)
    nvgBezierTo(nvg_, x - 5, y + 10, x - 10, y + 5, x - 12, y - 5)
    nvgBezierTo(nvg_, x - 15, y - 15, x - 8, y - 25, x, y - 35)
    nvgClosePath(nvg_)
    
    -- ç«ç„°æ¸å˜ï¼ˆæ©™è‰²åˆ°é»„è‰²ï¼‰
    local flameGrad = nvgLinearGradient(nvg_, x, y + 10, x, y - 35,
        nvgRGBA(255, 100, 0, 255),
        nvgRGBA(255, 220, 50, 255))
    nvgFillPaint(nvg_, flameGrad)
    nvgFill(nvg_)
    
    -- ç«ç„°å†…æ ¸ï¼ˆäº®é»„è‰²ï¼‰
    nvgBeginPath(nvg_)
    nvgMoveTo(nvg_, x, y - 20)
    nvgBezierTo(nvg_, x + 4, y - 12, x + 6, y - 5, x + 4, y)
    nvgBezierTo(nvg_, x + 2, y + 3, x, y + 5, x, y + 5)
    nvgBezierTo(nvg_, x, y + 5, x - 2, y + 3, x - 4, y)
    nvgBezierTo(nvg_, x - 6, y - 5, x - 4, y - 12, x, y - 20)
    nvgClosePath(nvg_)
    nvgFillColor(nvg_, nvgRGBA(255, 250, 180, 255))
    nvgFill(nvg_)
end

function DrawTowerSpots(spots)
    for _, spot in ipairs(spots) do
        if not spot.tower then
            local radius = CONFIG.GridSize / 2 - 5  -- åœ†å½¢åŠå¾„
            DrawCylinderHole(nvg_, spot.x, spot.y, radius)
        end
    end
end


-- ç»˜åˆ¶å‡¹é™·çš„åœ†æŸ±å½¢æ´
-- cx, cy: åœ†å¿ƒä½ç½®
-- radius: åœ†çš„åŠå¾„
function DrawCylinderHole(ctx, cx, cy, radius)
    -- é¢œè‰²å®šä¹‰ - å‚è€ƒåŸå›¾
    local darkColor = nvgRGBA(12, 130, 129, 255)      -- æ·±è‰²é˜´å½±ï¼ˆå‡¹é™·ä¾§å£ï¼‰
    local brightColor = nvgRGBA(45, 190, 180, 255)  -- äº®è‰²é’ç»¿ï¼ˆåœ†æŸ±åº•éƒ¨ï¼‰

    -- å…ˆç”»æ•´ä¸ªåœ†å½¢åº•è‰²ï¼ˆæ·±è‰²é˜´å½±ï¼‰
    nvgBeginPath(ctx)
    nvgCircle(ctx, cx, cy, radius)
    nvgFillColor(ctx, darkColor)
    nvgFill(ctx)

    -- ç”»ä¸‹åŠéƒ¨åˆ†çš„äº®è‰²ï¼ˆåœ†æŸ±åº•éƒ¨ï¼‰
    -- å…³é”®ï¼šç”¨æ¤­åœ†å¼§ä½œä¸ºä¸Šè¾¹ç•Œï¼Œå½¢æˆæœˆç‰™å½¢çš„é˜´å½±
    local edgeOffsetY = radius * 0.2  -- å¼§çº¿ä¸¤ç«¯å¾€ä¸‹åç§»ï¼ˆæ­£å€¼å¾€ä¸‹ï¼Œè°ƒè¿™ä¸ªè®©æ•´ä½“ä¸‹ç§»ï¼‰
    local arcRadiusY = radius * 0.7   -- æ¤­åœ†å¼§çš„å‚ç›´åŠå¾„ï¼ˆå¼¯æ›²ç¨‹åº¦ï¼‰

    -- è®¡ç®—å¼§çº¿ä¸¤ç«¯åœ¨åœ†ä¸Šçš„ä½ç½®
    local edgeAngle = math.asin(edgeOffsetY / radius)  -- æ ¹æ®Yåç§»è®¡ç®—è§’åº¦
    local edgeX = radius * math.cos(edgeAngle)         -- å¯¹åº”çš„Xåæ ‡

    nvgBeginPath(ctx)
    -- ä»å·¦è¾¹å¼€å§‹ï¼ˆå¾€ä¸‹åç§»åçš„ä½ç½®ï¼‰
    nvgMoveTo(ctx, cx - edgeX, cy + edgeOffsetY)
    -- ç”»å¤–åœ†çš„ä¸‹åŠå¼§ï¼ˆä»å·¦åˆ°å³ï¼Œè§’åº¦è°ƒæ•´ï¼‰
    nvgArc(ctx, cx, cy, radius, math.pi - edgeAngle, edgeAngle, 1)
    -- ç”»æ¤­åœ†å¼§ä½œä¸ºé¡¶éƒ¨è¾¹ç•Œï¼ˆä»å³åˆ°å·¦ï¼‰
    nvgBezierTo(ctx,
        cx + edgeX * 0.55, cy + edgeOffsetY - arcRadiusY,
        cx - edgeX * 0.55, cy + edgeOffsetY - arcRadiusY,
        cx - edgeX, cy + edgeOffsetY
    )
    nvgClosePath(ctx)
    nvgFillColor(ctx, brightColor)
    nvgFill(ctx)
end


function DrawTowers()
    for _, tower in ipairs(towers_) do
        local config = TowerTypes[tower.type]
        local mult = UpgradeMultipliers[tower.level]
        local size = 16 + tower.level * 4
        local color = config.color
        local range = config.range * mult.range
        
        -- å‡é€Ÿå¡”å§‹ç»ˆæ˜¾ç¤ºèŒƒå›´ï¼ˆæ·¡è‰²ï¼‰
        if tower.type == "slow" then
            -- èŒƒå›´åº•è‰²
            local rangeGrad = nvgRadialGradient(nvg_, tower.x, tower.y, 0, range,
                nvgRGBA(150, 220, 255, 20),
                nvgRGBA(150, 220, 255, 5))
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, tower.x, tower.y, range)
            nvgFillPaint(nvg_, rangeGrad)
            nvgFill(nvg_)
            
            -- èŒƒå›´è¾¹æ¡†
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, tower.x, tower.y, range)
            nvgStrokeColor(nvg_, nvgRGBA(150, 220, 255, 40))
            nvgStrokeWidth(nvg_, 2)
            nvgStroke(nvg_)
            
            -- è„‰å†²åŠ¨ç”»
            if tower.pulseTimer and tower.pulseTimer > 0 then
                local pulseRatio = tower.pulseTimer / 0.3
                nvgBeginPath(nvg_)
                nvgCircle(nvg_, tower.x, tower.y, range * (1 - pulseRatio * 0.2))
                nvgStrokeColor(nvg_, nvgRGBA(150, 220, 255, 150 * pulseRatio))
                nvgStrokeWidth(nvg_, 4 * pulseRatio)
                nvgStroke(nvg_)
            end
        end
        
        -- æ”»å‡»èŒƒå›´ï¼ˆé€‰ä¸­æ—¶æ˜¾ç¤ºï¼‰
        if selectedTowerSpot_ and selectedTowerSpot_.tower == tower then
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, tower.x, tower.y, range)
            nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 30))
            nvgFill(nvg_)
            nvgStrokeColor(nvg_, nvgRGBA(255, 255, 255, 80))
            nvgStrokeWidth(nvg_, 2)
            nvgStroke(nvg_)
        end
        
        -- è·å–æ”»å‡»åŠ¨ç”»åç§»å’Œç¼©æ”¾
        local recoilX = tower.recoilX or 0
        local recoilY = tower.recoilY or 0
        local scaleAnim = tower.scaleAnim or 1.0
        
        -- åº”ç”¨åŠ¨ç”»åçš„ç»˜åˆ¶ä½ç½®
        local drawX = tower.x + recoilX
        local drawY = tower.y + recoilY
        local drawSize = size * scaleAnim
        
        -- å¡”é˜´å½±ï¼ˆåœ¨å¡”ä¸‹æ–¹åç§»ç»˜åˆ¶ï¼Œä¸å—åååŠ›å½±å“ï¼‰
        local shadowOffsetY = size * 0.9
        local shadowSize = size + 12
        nvgBeginPath(nvg_)
        nvgEllipse(nvg_, tower.x, tower.y + shadowOffsetY, shadowSize, shadowSize * 0.5)
        nvgFillColor(nvg_, nvgRGBA(0, 0, 0, 80))
        nvgFill(nvg_)
        
        -- å¡”åº•åº§ï¼ˆåº”ç”¨åŠ¨ç”»åç§»å’Œç¼©æ”¾ï¼Œä¸æ—‹è½¬ï¼‰
        nvgBeginPath(nvg_)
        nvgCircle(nvg_, drawX, drawY, (size + 8) * scaleAnim)
        nvgFillColor(nvg_, nvgRGBA(60, 60, 60, 200))
        nvgFill(nvg_)
        
        -- æ¿€å…‰å¡”éœ€è¦æ—‹è½¬ç»˜åˆ¶ï¼ˆæ¿€å…‰æœ¬èº«åœ¨ DrawLasers ä¸­ç»˜åˆ¶ï¼Œåœ¨æ•Œäººä¹‹åï¼‰
        if config.projectileType == "laser" then
            nvgSave(nvg_)
            nvgTranslate(nvg_, drawX, drawY)
            nvgRotate(nvg_, tower.rotation or 0)
            -- å¡”å½¢çŠ¶ï¼ˆåœ¨åŸç‚¹ç»˜åˆ¶ï¼Œå·²ç»å¹³ç§»è¿‡äº†ï¼‰
            DrawShape(config.shape, 0, 0, drawSize, color, tower.level)
            nvgRestore(nvg_)
        else
            -- å…¶ä»–å¡”å½¢çŠ¶ï¼ˆåº”ç”¨åŠ¨ç”»åç§»å’Œç¼©æ”¾ï¼‰
            DrawShape(config.shape, drawX, drawY, drawSize, color, tower.level)
        end
        
        -- ç­‰çº§æŒ‡ç¤ºï¼ˆä¸å—åŠ¨ç”»å½±å“ï¼Œå›ºå®šåœ¨åŸä½ï¼‰
        if tower.level > 1 then
            nvgFontFace(nvg_, "sans")
            nvgFontSize(nvg_, 18)
            nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
            nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
            nvgText(nvg_, tower.x, tower.y + size + 18, "Lv" .. tower.level, nil)
        end
    end
end

-- ç»˜åˆ¶æ¿€å…‰ï¼ˆå•ç‹¬ç»˜åˆ¶ï¼Œç¡®ä¿åœ¨æ•Œäººä¹‹ä¸Šï¼‰
function DrawLasers()
    for _, tower in ipairs(towers_) do
        local config = TowerTypes[tower.type]
        
        if config.projectileType == "laser" and tower.target then
            local recoilX = tower.recoilX or 0
            local recoilY = tower.recoilY or 0
            local drawX = tower.x + recoilX
            local drawY = tower.y + recoilY
            
            -- æ¿€å…‰å…‰æ™•ï¼ˆå…ˆç»˜åˆ¶ï¼Œåœ¨ä¸‹å±‚ï¼‰
            nvgBeginPath(nvg_)
            nvgMoveTo(nvg_, drawX, drawY)
            nvgLineTo(nvg_, tower.target.x, tower.target.y)
            nvgStrokeColor(nvg_, nvgRGBA(255, 150, 150, 100))
            nvgStrokeWidth(nvg_, 12)
            nvgStroke(nvg_)
            
            -- æ¿€å…‰ä¸»ä½“
            nvgBeginPath(nvg_)
            nvgMoveTo(nvg_, drawX, drawY)
            nvgLineTo(nvg_, tower.target.x, tower.target.y)
            nvgStrokeColor(nvg_, nvgRGBA(255, 50, 50, 200))
            nvgStrokeWidth(nvg_, 5)
            nvgStroke(nvg_)
        end
    end
end

function DrawShape(shape, x, y, size, color, level)
    -- é¢œè‰²éšç­‰çº§åŠ æ·±
    local r = math.min(255, color[1] + (level - 1) * 20)
    local g = math.min(255, color[2] + (level - 1) * 20)
    local b = math.min(255, color[3] + (level - 1) * 20)
    
    nvgBeginPath(nvg_)
    
    if shape == "circle" then
        nvgCircle(nvg_, x, y, size)
    elseif shape == "triangle" then
        nvgMoveTo(nvg_, x, y - size)
        nvgLineTo(nvg_, x + size * 0.866, y + size * 0.5)
        nvgLineTo(nvg_, x - size * 0.866, y + size * 0.5)
        nvgClosePath(nvg_)
    elseif shape == "square" then
        nvgRect(nvg_, x - size * 0.7, y - size * 0.7, size * 1.4, size * 1.4)
    elseif shape == "diamond" then
        nvgMoveTo(nvg_, x, y - size)
        nvgLineTo(nvg_, x + size, y)
        nvgLineTo(nvg_, x, y + size)
        nvgLineTo(nvg_, x - size, y)
        nvgClosePath(nvg_)
    elseif shape == "hexagon" then
        for i = 0, 5 do
            local angle = (i / 6) * math.pi * 2 - math.pi / 2
            local px = x + math.cos(angle) * size
            local py = y + math.sin(angle) * size
            if i == 0 then
                nvgMoveTo(nvg_, px, py)
            else
                nvgLineTo(nvg_, px, py)
            end
        end
        nvgClosePath(nvg_)
    end
    
    nvgFillColor(nvg_, nvgRGBA(r, g, b, 255))
    nvgFill(nvg_)
    
    nvgStrokeColor(nvg_, nvgRGBA(255, 255, 255, 150))
    nvgStrokeWidth(nvg_, 2)
    nvgStroke(nvg_)
end

-- åœ¨åŸç‚¹ç»˜åˆ¶å½¢çŠ¶ï¼ˆç”¨äºå·²æ—‹è½¬çš„æ•Œäººï¼‰
function DrawShapeRotated(shape, size, color, level, healthRatio)
    healthRatio = healthRatio or 1.0
    
    -- é¢œè‰²
    local r = math.min(255, color[1])
    local g = math.min(255, color[2])
    local b = math.min(255, color[3])
    
    -- å†…éƒ¨å¡«å……å¤§å°éšè¡€é‡ç¼©å°
    local innerSize = size * healthRatio
    
    -- å…ˆç»˜åˆ¶æ·±è‰²èƒŒæ™¯ï¼ˆè¡¨ç¤ºæŸå¤±çš„ç”Ÿå‘½ï¼‰
    nvgBeginPath(nvg_)
    if shape == "circle" then
        nvgCircle(nvg_, 0, 0, size)
    elseif shape == "triangle" then
        nvgMoveTo(nvg_, size, 0)
        nvgLineTo(nvg_, -size * 0.5, size * 0.866)
        nvgLineTo(nvg_, -size * 0.5, -size * 0.866)
        nvgClosePath(nvg_)
    elseif shape == "square" then
        nvgRect(nvg_, -size * 0.7, -size * 0.7, size * 1.4, size * 1.4)
    elseif shape == "diamond" then
        nvgMoveTo(nvg_, size, 0)
        nvgLineTo(nvg_, 0, size)
        nvgLineTo(nvg_, -size, 0)
        nvgLineTo(nvg_, 0, -size)
        nvgClosePath(nvg_)
    elseif shape == "hexagon" then
        for i = 0, 5 do
            local angle = (i / 6) * math.pi * 2
            local px = math.cos(angle) * size
            local py = math.sin(angle) * size
            if i == 0 then
                nvgMoveTo(nvg_, px, py)
            else
                nvgLineTo(nvg_, px, py)
            end
        end
        nvgClosePath(nvg_)
    end
    nvgFillColor(nvg_, nvgRGBA(30, 30, 30, 255))
    nvgFill(nvg_)
    
    -- ç»˜åˆ¶å†…éƒ¨é¢œè‰²å¡«å……ï¼ˆå¤§å°éšè¡€é‡ç¼©å°ï¼‰
    if innerSize > 0.5 then
        nvgBeginPath(nvg_)
        if shape == "circle" then
            nvgCircle(nvg_, 0, 0, innerSize)
        elseif shape == "triangle" then
            nvgMoveTo(nvg_, innerSize, 0)
            nvgLineTo(nvg_, -innerSize * 0.5, innerSize * 0.866)
            nvgLineTo(nvg_, -innerSize * 0.5, -innerSize * 0.866)
            nvgClosePath(nvg_)
        elseif shape == "square" then
            nvgRect(nvg_, -innerSize * 0.7, -innerSize * 0.7, innerSize * 1.4, innerSize * 1.4)
        elseif shape == "diamond" then
            nvgMoveTo(nvg_, innerSize, 0)
            nvgLineTo(nvg_, 0, innerSize)
            nvgLineTo(nvg_, -innerSize, 0)
            nvgLineTo(nvg_, 0, -innerSize)
            nvgClosePath(nvg_)
        elseif shape == "hexagon" then
            for i = 0, 5 do
                local angle = (i / 6) * math.pi * 2
                local px = math.cos(angle) * innerSize
                local py = math.sin(angle) * innerSize
                if i == 0 then
                    nvgMoveTo(nvg_, px, py)
                else
                    nvgLineTo(nvg_, px, py)
                end
            end
            nvgClosePath(nvg_)
        end
        nvgFillColor(nvg_, nvgRGBA(r, g, b, 255))
        nvgFill(nvg_)
    end
    
    -- æœ€åç»˜åˆ¶çº¯ç™½è‰²æè¾¹ï¼ˆå¤–åœˆï¼‰
    nvgBeginPath(nvg_)
    if shape == "circle" then
        nvgCircle(nvg_, 0, 0, size)
    elseif shape == "triangle" then
        nvgMoveTo(nvg_, size, 0)
        nvgLineTo(nvg_, -size * 0.5, size * 0.866)
        nvgLineTo(nvg_, -size * 0.5, -size * 0.866)
        nvgClosePath(nvg_)
    elseif shape == "square" then
        nvgRect(nvg_, -size * 0.7, -size * 0.7, size * 1.4, size * 1.4)
    elseif shape == "diamond" then
        nvgMoveTo(nvg_, size, 0)
        nvgLineTo(nvg_, 0, size)
        nvgLineTo(nvg_, -size, 0)
        nvgLineTo(nvg_, 0, -size)
        nvgClosePath(nvg_)
    elseif shape == "hexagon" then
        for i = 0, 5 do
            local angle = (i / 6) * math.pi * 2
            local px = math.cos(angle) * size
            local py = math.sin(angle) * size
            if i == 0 then
                nvgMoveTo(nvg_, px, py)
            else
                nvgLineTo(nvg_, px, py)
            end
        end
        nvgClosePath(nvg_)
    end
    nvgStrokeColor(nvg_, nvgRGBA(255, 255, 255, 255))
    nvgStrokeWidth(nvg_, 3)
    nvgStroke(nvg_)
end

-- åœ¨åŸç‚¹ç»˜åˆ¶æˆ˜è½¦ï¼ˆç”¨äºå·²æ—‹è½¬çš„æ•Œäººï¼‰
function DrawChariotRotated(size, color, healthRatio)
    healthRatio = healthRatio or 1.0
    
    -- å†…éƒ¨å¡«å……å¤§å°éšè¡€é‡ç¼©å°
    local innerSize = size * healthRatio
    
    -- å¤–åœˆæ·±è‰²èƒŒæ™¯
    nvgBeginPath(nvg_)
    nvgCircle(nvg_, 0, 0, size)
    nvgFillColor(nvg_, nvgRGBA(30, 30, 30, 255))
    nvgFill(nvg_)
    
    -- å†…åœˆé¢œè‰²å¡«å……ï¼ˆå¤§å°éšè¡€é‡ç¼©å°ï¼‰
    if innerSize > 0.5 then
        nvgBeginPath(nvg_)
        nvgCircle(nvg_, 0, 0, innerSize)
        nvgFillColor(nvg_, nvgRGBA(color[1], color[2], color[3], 255))
        nvgFill(nvg_)
    end
    
    -- å¤–åœˆçº¯ç™½è‰²æè¾¹
    nvgBeginPath(nvg_)
    nvgCircle(nvg_, 0, 0, size)
    nvgStrokeColor(nvg_, nvgRGBA(255, 255, 255, 255))
    nvgStrokeWidth(nvg_, 4)
    nvgStroke(nvg_)
    
    -- ä¸­å¿ƒåœ†ç‚¹
    nvgBeginPath(nvg_)
    nvgCircle(nvg_, 0, 0, size * 0.12)
    nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 200))
    nvgFill(nvg_)
    
    -- å‰è¿›æ–¹å‘æŒ‡ç¤ºï¼ˆå°ç®­å¤´ï¼‰
    nvgBeginPath(nvg_)
    nvgMoveTo(nvg_, size * 0.5, 0)
    nvgLineTo(nvg_, size * 0.25, -size * 0.2)
    nvgLineTo(nvg_, size * 0.25, size * 0.2)
    nvgClosePath(nvg_)
    nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
    nvgFill(nvg_)
end

function DrawEnemies()
    for _, enemy in ipairs(enemies_) do
        local config = EnemyTypes[enemy.type]
        local color = config.color
        local size = config.size
        local healthRatio = enemy.health / enemy.maxHealth
        
        -- åº”ç”¨å—å‡»å¼¹ç°§åç§»
        local drawX = enemy.x + (enemy.hitRecoilOffsetX or 0)
        local drawY = enemy.y + (enemy.hitRecoilOffsetY or 0)
        local rotation = enemy.rotation or 0
        
        -- å—å‡»é—ªçƒæ•ˆæœï¼ˆå—å‡»æ—¶å˜äº®ï¼‰
        local drawColor = color
        if enemy.hitRecoilTimer and enemy.hitRecoilTimer > 0 then
            local flashRatio = enemy.hitRecoilTimer / 0.35
            drawColor = {
                math.min(255, color[1] + 80 * flashRatio),
                math.min(255, color[2] + 80 * flashRatio),
                math.min(255, color[3] + 80 * flashRatio),
            }
        end
        
        -- å‡é€Ÿæ•ˆæœï¼ˆä¸æ—‹è½¬ï¼‰
        if enemy.slowTimer > 0 then
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, drawX, drawY, size + 8)
            nvgFillColor(nvg_, nvgRGBA(150, 200, 255, 60))
            nvgFill(nvg_)
            nvgStrokeColor(nvg_, nvgRGBA(150, 200, 255, 120))
            nvgStrokeWidth(nvg_, 2)
            nvgStroke(nvg_)
        end
        
        -- ä¿å­˜çŠ¶æ€ï¼Œåº”ç”¨æ—‹è½¬
        nvgSave(nvg_)
        nvgTranslate(nvg_, drawX, drawY)
        nvgRotate(nvg_, rotation)
        
        -- æ•Œäººå½¢çŠ¶ï¼ˆåœ¨åŸç‚¹ç»˜åˆ¶ï¼Œä¼ å…¥è¡€é‡æ¯”ä¾‹ï¼‰
        if config.shape == "chariot" then
            -- æˆ˜è½¦ç‰¹æ®Šç»˜åˆ¶
            DrawChariotRotated(size, drawColor, healthRatio)
        else
            DrawShapeRotated(config.shape, size, drawColor, 1, healthRatio)
        end
        
        -- æ¢å¤çŠ¶æ€
        nvgRestore(nvg_)
    end
end

-- ç»˜åˆ¶æˆ˜è½¦ï¼ˆå¤§åœ†å†…å«8ä¸ªå°åœ†ï¼‰
function DrawChariot(x, y, size, color)
    -- å¤–åœˆå¤§åœ†ï¼ˆåº•è‰²ï¼‰
    nvgBeginPath(nvg_)
    nvgCircle(nvg_, x, y, size)
    nvgFillColor(nvg_, nvgRGBA(color[1] - 50, color[2] - 50, color[3] - 50, 255))
    nvgFill(nvg_)
    
    -- å¤–åœˆè¾¹æ¡†
    nvgBeginPath(nvg_)
    nvgCircle(nvg_, x, y, size)
    nvgStrokeColor(nvg_, nvgRGBA(color[1], color[2], color[3], 255))
    nvgStrokeWidth(nvg_, 4)
    nvgStroke(nvg_)
    
    -- å†…éƒ¨8ä¸ªå°åœ†ï¼ˆä»£è¡¨è½½ç€çš„æ•Œäººï¼‰
    local innerRadius = size * 0.6
    local smallSize = size * 0.22
    local normalColor = EnemyTypes.normal.color
    
    for i = 1, 8 do
        local angle = (i - 1) * (2 * math.pi / 8) - math.pi / 2
        local cx = x + math.cos(angle) * innerRadius
        local cy = y + math.sin(angle) * innerRadius
        
        -- å°åœ†å¡«å……
        nvgBeginPath(nvg_)
        nvgCircle(nvg_, cx, cy, smallSize)
        nvgFillColor(nvg_, nvgRGBA(normalColor[1], normalColor[2], normalColor[3], 255))
        nvgFill(nvg_)
        
        -- å°åœ†è¾¹æ¡†
        nvgBeginPath(nvg_)
        nvgCircle(nvg_, cx, cy, smallSize)
        nvgStrokeColor(nvg_, nvgRGBA(normalColor[1] - 30, normalColor[2] - 30, normalColor[3] - 30, 255))
        nvgStrokeWidth(nvg_, 2)
        nvgStroke(nvg_)
    end
    
    -- ä¸­å¿ƒæ ‡è¯†
    nvgBeginPath(nvg_)
    nvgCircle(nvg_, x, y, smallSize * 0.8)
    nvgFillColor(nvg_, nvgRGBA(color[1], color[2], color[3], 255))
    nvgFill(nvg_)
end

function DrawProjectiles()
    for _, proj in ipairs(projectiles_) do
        local size = 10
        local color = {255, 255, 100}
        
        if proj.type == "arrow" then
            -- ç®­å¡”æŠ•å°„ç‰©ï¼šé”¥å½¢å¸¦æ‹–å°¾æ•ˆæœ
            color = {200, 200, 255}
            
            -- è®¡ç®—é£è¡Œæ–¹å‘
            local target = proj.targetEnemy
            if target then
                local dx = target.x - proj.x
                local dy = target.y - proj.y
                local dist = math.sqrt(dx * dx + dy * dy)
                if dist > 0 then
                    local dirX = dx / dist
                    local dirY = dy / dist
                    local angle = math.atan2(dy, dx)
                    
                    -- é”¥å½¢å‚æ•°
                    local tipLength = 18    -- å°–ç«¯é•¿åº¦
                    local tailLength = 35   -- æ‹–å°¾é•¿åº¦
                    local tailWidth = 12    -- æ‹–å°¾å®½åº¦
                    
                    -- è®¡ç®—é”¥å½¢é¡¶ç‚¹ï¼ˆå°–ç«¯ï¼‰
                    local tipX = proj.x + dirX * tipLength
                    local tipY = proj.y + dirY * tipLength
                    
                    -- è®¡ç®—æ‹–å°¾æœ«ç«¯ä¸­å¿ƒ
                    local tailX = proj.x - dirX * tailLength
                    local tailY = proj.y - dirY * tailLength
                    
                    -- è®¡ç®—æ‹–å°¾ä¸¤ä¾§ç‚¹ï¼ˆå‚ç›´äºé£è¡Œæ–¹å‘ï¼‰
                    local perpX = -dirY
                    local perpY = dirX
                    local tail1X = proj.x + perpX * tailWidth * 0.5
                    local tail1Y = proj.y + perpY * tailWidth * 0.5
                    local tail2X = proj.x - perpX * tailWidth * 0.5
                    local tail2Y = proj.y - perpY * tailWidth * 0.5
                    
                    -- ç»˜åˆ¶æ‹–å°¾ï¼ˆæ¸å˜ä¸‰è§’å½¢ï¼‰
                    nvgBeginPath(nvg_)
                    nvgMoveTo(nvg_, tail1X, tail1Y)
                    nvgLineTo(nvg_, tail2X, tail2Y)
                    nvgLineTo(nvg_, tailX, tailY)
                    nvgClosePath(nvg_)
                    nvgFillColor(nvg_, nvgRGBA(color[1], color[2], color[3], 60))
                    nvgFill(nvg_)
                    
                    -- ç»˜åˆ¶ä¸­é—´æ‹–å°¾ï¼ˆæ›´äº®ï¼‰
                    local midTailX = proj.x - dirX * tailLength * 0.6
                    local midTailY = proj.y - dirY * tailLength * 0.6
                    nvgBeginPath(nvg_)
                    nvgMoveTo(nvg_, tail1X, tail1Y)
                    nvgLineTo(nvg_, tail2X, tail2Y)
                    nvgLineTo(nvg_, midTailX, midTailY)
                    nvgClosePath(nvg_)
                    nvgFillColor(nvg_, nvgRGBA(color[1], color[2], color[3], 120))
                    nvgFill(nvg_)
                    
                    -- ç»˜åˆ¶ç®­å¤´ä¸»ä½“ï¼ˆé”¥å½¢ï¼‰
                    nvgBeginPath(nvg_)
                    nvgMoveTo(nvg_, tipX, tipY)
                    nvgLineTo(nvg_, tail1X, tail1Y)
                    nvgLineTo(nvg_, tail2X, tail2Y)
                    nvgClosePath(nvg_)
                    nvgFillColor(nvg_, nvgRGBA(color[1], color[2], color[3], 255))
                    nvgFill(nvg_)
                    
                    -- é«˜äº®å°–ç«¯
                    nvgBeginPath(nvg_)
                    nvgCircle(nvg_, tipX, tipY, 4)
                    nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
                    nvgFill(nvg_)
                end
            end
        elseif proj.type == "cannonball" then
            color = {100, 100, 100}
            size = 12
            
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, proj.x, proj.y, size)
            nvgFillColor(nvg_, nvgRGBA(color[1], color[2], color[3], 255))
            nvgFill(nvg_)
            
            -- å…‰æ™•
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, proj.x, proj.y, size + 5)
            nvgFillColor(nvg_, nvgRGBA(color[1], color[2], color[3], 80))
            nvgFill(nvg_)
        elseif proj.type == "ice" then
            color = {150, 220, 255}
            size = 10
            
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, proj.x, proj.y, size)
            nvgFillColor(nvg_, nvgRGBA(color[1], color[2], color[3], 255))
            nvgFill(nvg_)
            
            -- å…‰æ™•
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, proj.x, proj.y, size + 5)
            nvgFillColor(nvg_, nvgRGBA(color[1], color[2], color[3], 80))
            nvgFill(nvg_)
        else
            -- é»˜è®¤æŠ•å°„ç‰©
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, proj.x, proj.y, size)
            nvgFillColor(nvg_, nvgRGBA(color[1], color[2], color[3], 255))
            nvgFill(nvg_)
            
            -- å…‰æ™•
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, proj.x, proj.y, size + 5)
            nvgFillColor(nvg_, nvgRGBA(color[1], color[2], color[3], 80))
            nvgFill(nvg_)
        end
    end
end

function DrawParticles()
    for _, p in ipairs(particles_) do
        local alpha = (p.life / p.maxLife) * 255
        local lifeRatio = p.life / p.maxLife
        local ptype = p.type or "circle"
        
        if ptype == "circle" then
            -- æ™®é€šåœ†å½¢ç²’å­
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, p.x, p.y, p.size * lifeRatio)
            nvgFillColor(nvg_, nvgRGBA(p.color[1], p.color[2], p.color[3], alpha))
            nvgFill(nvg_)
            
        elseif ptype == "spark" then
            -- ç«èŠ±ç²’å­ï¼ˆå¸¦å…‰æ™•ï¼‰
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, p.x, p.y, p.size * lifeRatio)
            nvgFillColor(nvg_, nvgRGBA(p.color[1], p.color[2], p.color[3], alpha))
            nvgFill(nvg_)
            -- å…‰æ™•
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, p.x, p.y, p.size * lifeRatio * 2)
            nvgFillColor(nvg_, nvgRGBA(p.color[1], p.color[2], p.color[3], alpha * 0.3))
            nvgFill(nvg_)
            
        elseif ptype == "shockwave" then
            -- å†²å‡»æ³¢ï¼ˆæ‰©å±•çš„åœ†ç¯ï¼‰
            local expandSize = p.size * (1 - lifeRatio) * 2
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, p.x, p.y, expandSize)
            nvgStrokeColor(nvg_, nvgRGBA(p.color[1], p.color[2], p.color[3], alpha * 0.8))
            nvgStrokeWidth(nvg_, 4 * lifeRatio)
            nvgStroke(nvg_)
            
        elseif ptype == "smoke" then
            -- çƒŸé›¾ï¼ˆæ¸å˜å˜å¤§ï¼‰
            local smokeSize = p.size * (1 + (1 - lifeRatio) * 0.5)
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, p.x, p.y, smokeSize)
            nvgFillColor(nvg_, nvgRGBA(p.color[1], p.color[2], p.color[3], alpha * 0.5))
            nvgFill(nvg_)
            
        elseif ptype == "flash" then
            -- é—ªå…‰ï¼ˆå¿«é€Ÿæ¶ˆå¤±çš„äº®å…‰ï¼‰
            local flashGrad = nvgRadialGradient(nvg_, p.x, p.y, 0, p.size * lifeRatio,
                nvgRGBA(p.color[1], p.color[2], p.color[3], alpha),
                nvgRGBA(p.color[1], p.color[2], p.color[3], 0))
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, p.x, p.y, p.size * lifeRatio)
            nvgFillPaint(nvg_, flashGrad)
            nvgFill(nvg_)
            
        elseif ptype == "trail" then
            -- è½¨è¿¹ç²’å­
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, p.x, p.y, p.size * lifeRatio)
            nvgFillColor(nvg_, nvgRGBA(p.color[1], p.color[2], p.color[3], alpha * 0.7))
            nvgFill(nvg_)
            
        elseif ptype == "beam" then
            -- å…‰æŸ±æ•ˆæœ
            nvgBeginPath(nvg_)
            nvgRect(nvg_, p.x - 5, p.y - 100 * lifeRatio, 10, 100 * lifeRatio)
            nvgFillColor(nvg_, nvgRGBA(p.color[1], p.color[2], p.color[3], alpha * 0.6))
            nvgFill(nvg_)
            
        elseif ptype == "text" then
            -- é£˜å­—æ•ˆæœ
            nvgFontFace(nvg_, "sans")
            nvgFontSize(nvg_, p.size)
            nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
            nvgFillColor(nvg_, nvgRGBA(p.color[1], p.color[2], p.color[3], alpha))
            nvgText(nvg_, p.x, p.y, p.text or "", nil)
            
        elseif ptype == "snowflake" then
            -- é›ªèŠ±/å†°å†»ç²’å­
            nvgBeginPath(nvg_)
            local size = p.size * lifeRatio
            -- ç”»åå­—
            nvgMoveTo(nvg_, p.x - size, p.y)
            nvgLineTo(nvg_, p.x + size, p.y)
            nvgMoveTo(nvg_, p.x, p.y - size)
            nvgLineTo(nvg_, p.x, p.y + size)
            -- ç”»æ–œçº¿
            nvgMoveTo(nvg_, p.x - size * 0.7, p.y - size * 0.7)
            nvgLineTo(nvg_, p.x + size * 0.7, p.y + size * 0.7)
            nvgMoveTo(nvg_, p.x + size * 0.7, p.y - size * 0.7)
            nvgLineTo(nvg_, p.x - size * 0.7, p.y + size * 0.7)
            nvgStrokeColor(nvg_, nvgRGBA(p.color[1], p.color[2], p.color[3], alpha))
            nvgStrokeWidth(nvg_, 2)
            nvgStroke(nvg_)
            
        elseif ptype == "split_ring" then
            -- æˆ˜è½¦åˆ†è£‚å…‰ç¯æ•ˆæœ
            local expandRatio = 1 - lifeRatio  -- ä»0åˆ°1æ‰©å±•
            local currentSize = p.size * expandRatio
            
            -- å¤–æ‰©å…‰ç¯
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, p.x, p.y, currentSize)
            nvgStrokeColor(nvg_, nvgRGBA(p.color[1], p.color[2], p.color[3], alpha * 0.9))
            nvgStrokeWidth(nvg_, 6 * lifeRatio)
            nvgStroke(nvg_)
            
            -- ä¸­å¿ƒé—ªå…‰
            if lifeRatio > 0.5 then
                local flashAlpha = (lifeRatio - 0.5) * 2 * alpha
                local flashGrad = nvgRadialGradient(nvg_, p.x, p.y, 0, p.size * 0.3,
                    nvgRGBA(255, 255, 200, flashAlpha),
                    nvgRGBA(255, 200, 100, 0))
                nvgBeginPath(nvg_)
                nvgCircle(nvg_, p.x, p.y, p.size * 0.3)
                nvgFillPaint(nvg_, flashGrad)
                nvgFill(nvg_)
            end
            
        elseif ptype == "slow_pulse" then
            -- å‡é€Ÿå¡”è„‰å†²æ•ˆæœï¼ˆæ‰©æ•£çš„å†°å†»åœˆï¼‰
            local expandRatio = 1 - lifeRatio  -- ä»0åˆ°1æ‰©å±•
            local currentSize = p.size * expandRatio
            
            -- å¤–åœˆ
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, p.x, p.y, currentSize)
            nvgStrokeColor(nvg_, nvgRGBA(p.color[1], p.color[2], p.color[3], alpha * 0.8))
            nvgStrokeWidth(nvg_, 4 * lifeRatio)
            nvgStroke(nvg_)
            
            -- å†…éƒ¨å¡«å……ï¼ˆæ¸å˜ï¼‰
            local fillGrad = nvgRadialGradient(nvg_, p.x, p.y, 0, currentSize,
                nvgRGBA(p.color[1], p.color[2], p.color[3], alpha * 0.3),
                nvgRGBA(p.color[1], p.color[2], p.color[3], 0))
            nvgBeginPath(nvg_)
            nvgCircle(nvg_, p.x, p.y, currentSize)
            nvgFillPaint(nvg_, fillGrad)
            nvgFill(nvg_)
        end
    end
end

function DrawTowerMenu(spot)
    local menuX = spot.x + 60
    local menuY = spot.y - 100
    local buttonWidth = 160
    local buttonHeight = 48
    
    if spot.tower then
        -- å·²æœ‰å¡”ï¼šæ˜¾ç¤ºå‡çº§/å‡ºå”®
        local tower = spot.tower
        local config = TowerTypes[tower.type]
        
        -- èœå•èƒŒæ™¯
        nvgBeginPath(nvg_)
        nvgRoundedRect(nvg_, menuX - 10, menuY - 10, buttonWidth + 20, 120, 10)
        nvgFillColor(nvg_, nvgRGBA(30, 30, 30, 230))
        nvgFill(nvg_)
        
        -- å‡çº§æŒ‰é’®
        local canUpgrade = tower.level < 3
        local nextMult = UpgradeMultipliers[tower.level + 1]
        local upgradeCost = 0
        if canUpgrade and nextMult then
            upgradeCost = math.floor(config.cost * nextMult.cost)
        end
        
        nvgBeginPath(nvg_)
        nvgRoundedRect(nvg_, menuX, menuY, buttonWidth, buttonHeight, 8)
        if canUpgrade and playerGold_ >= upgradeCost then
            nvgFillColor(nvg_, nvgRGBA(80, 150, 80, 255))
        else
            nvgFillColor(nvg_, nvgRGBA(80, 80, 80, 255))
        end
        nvgFill(nvg_)
        
        nvgFontFace(nvg_, "sans")
        nvgFontSize(nvg_, 22)
        nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
        nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
        if canUpgrade then
            nvgText(nvg_, menuX + buttonWidth / 2, menuY + buttonHeight / 2, "å‡çº§ $" .. upgradeCost, nil)
        else
            nvgText(nvg_, menuX + buttonWidth / 2, menuY + buttonHeight / 2, "å·²æ»¡çº§", nil)
        end
        
        -- å‡ºå”®æŒ‰é’®ï¼ˆåº”ç”¨æŠ€èƒ½æ ‘åŠ æˆæ˜¾ç¤ºï¼‰
        menuY = menuY + 58
        local sellBonus = GetSkillEffect("sell_refund")
        local sellValue = math.floor(tower.totalCost * (CONFIG.SellRefundRate + sellBonus))
        
        nvgBeginPath(nvg_)
        nvgRoundedRect(nvg_, menuX, menuY, buttonWidth, buttonHeight, 8)
        nvgFillColor(nvg_, nvgRGBA(150, 80, 80, 255))
        nvgFill(nvg_)
        
        nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
        nvgText(nvg_, menuX + buttonWidth / 2, menuY + buttonHeight / 2, "å‡ºå”® +$" .. sellValue, nil)
    else
        -- ç©ºåœ°ï¼šæ˜¾ç¤ºå¯å»ºé€ çš„å¡”
        local towerTypes = {"arrow", "cannon", "slow", "laser"}
        local menuHeight = #towerTypes * 58 + 16
        
        -- èœå•èƒŒæ™¯
        nvgBeginPath(nvg_)
        nvgRoundedRect(nvg_, menuX - 10, menuY - 10, buttonWidth + 20, menuHeight, 10)
        nvgFillColor(nvg_, nvgRGBA(30, 30, 30, 230))
        nvgFill(nvg_)
        
        -- è·å–å»ºé€ è´¹ç”¨æŠ˜æ‰£
        local costDiscount = GetSkillEffect("tower_cost")
        
        for i, ttype in ipairs(towerTypes) do
            local config = TowerTypes[ttype]
            local by = menuY + (i - 1) * 58
            -- åº”ç”¨æŠ€èƒ½æ ‘åŠ æˆè®¡ç®—å®é™…ä»·æ ¼
            local actualCost = math.floor(config.cost * (1 + costDiscount))
            local canBuy = playerGold_ >= actualCost
            
            nvgBeginPath(nvg_)
            nvgRoundedRect(nvg_, menuX, by, buttonWidth, buttonHeight, 8)
            if canBuy then
                nvgFillColor(nvg_, nvgRGBA(config.color[1], config.color[2], config.color[3], 200))
            else
                nvgFillColor(nvg_, nvgRGBA(60, 60, 60, 200))
            end
            nvgFill(nvg_)
            
            nvgFontFace(nvg_, "sans")
            nvgFontSize(nvg_, 22)
            nvgFillColor(nvg_, nvgRGBA(255, 255, 255, canBuy and 255 or 150))
            nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
            nvgText(nvg_, menuX + buttonWidth / 2, by + buttonHeight / 2, config.name .. " $" .. actualCost, nil)
        end
    end
end

function DrawHUD(width, height)
    -- é¡¶éƒ¨HUDèƒŒæ™¯
    nvgBeginPath(nvg_)
    nvgRect(nvg_, 0, 0, width, 60)
    nvgFillColor(nvg_, nvgRGBA(20, 20, 20, 200))
    nvgFill(nvg_)
    
    nvgFontFace(nvg_, "sans")
    nvgFontSize(nvg_, 32)
    nvgTextAlign(nvg_, NVG_ALIGN_LEFT + NVG_ALIGN_MIDDLE)
    
    -- é‡‘å¸
    nvgFillColor(nvg_, nvgRGBA(255, 220, 50, 255))
    nvgText(nvg_, 30, 30, "ğŸ’° " .. playerGold_, nil)
    
    -- ç”Ÿå‘½
    nvgFillColor(nvg_, nvgRGBA(255, 100, 100, 255))
    nvgText(nvg_, 240, 30, "â¤ï¸ " .. playerLives_, nil)
    
    -- æ³¢æ¬¡
    nvgFillColor(nvg_, nvgRGBA(100, 200, 255, 255))
    local level = Levels[selectedLevel_]
    nvgText(nvg_, 450, 30, "ğŸŒŠ æ³¢æ¬¡ " .. currentWave_ .. "/" .. #level.waves, nil)
    
    -- æ•Œäººæ•°é‡
    nvgFillColor(nvg_, nvgRGBA(200, 150, 255, 255))
    nvgText(nvg_, 750, 30, "ğŸ‘¾ æ•Œäºº " .. #enemies_, nil)
    
    -- å…³å¡å
    nvgTextAlign(nvg_, NVG_ALIGN_RIGHT + NVG_ALIGN_MIDDLE)
    nvgFillColor(nvg_, nvgRGBA(200, 200, 200, 255))
    nvgText(nvg_, width - 150, 30, level.name, nil)
    
    -- é€€å‡ºæŒ‰é’®ï¼ˆå³ä¸Šè§’ï¼‰
    local exitBtnWidth = 100
    local exitBtnHeight = 40
    local exitBtnX = width - exitBtnWidth - 20
    local exitBtnY = 10
    
    nvgBeginPath(nvg_)
    nvgRoundedRect(nvg_, exitBtnX, exitBtnY, exitBtnWidth, exitBtnHeight, 8)
    nvgFillColor(nvg_, nvgRGBA(150, 50, 50, 200))
    nvgFill(nvg_)
    
    nvgBeginPath(nvg_)
    nvgRoundedRect(nvg_, exitBtnX, exitBtnY, exitBtnWidth, exitBtnHeight, 8)
    nvgStrokeColor(nvg_, nvgRGBA(200, 80, 80, 255))
    nvgStrokeWidth(nvg_, 2)
    nvgStroke(nvg_)
    
    nvgFontSize(nvg_, 24)
    nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
    nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
    nvgText(nvg_, exitBtnX + exitBtnWidth / 2, exitBtnY + exitBtnHeight / 2, "é€€å‡º", nil)
    
    -- å³ä¸‹è§’"ä¸‹ä¸€æ³¢"æŒ‰é’®
    DrawNextWaveButton(width, height)
end

-- ç»˜åˆ¶ä¸‹ä¸€æ³¢æŒ‰é’®
function DrawNextWaveButton(width, height)
    local level = Levels[selectedLevel_]
    local buttonWidth = 180
    local buttonHeight = 60
    local bx = width - buttonWidth - 30
    local by = height - buttonHeight - 30
    
    -- æ£€æŸ¥æ˜¯å¦å¯ä»¥è§¦å‘ä¸‹ä¸€æ³¢
    local canTrigger = not waveActive_ and currentWave_ < #level.waves
    
    -- æŒ‰é’®èƒŒæ™¯
    nvgBeginPath(nvg_)
    nvgRoundedRect(nvg_, bx, by, buttonWidth, buttonHeight, 10)
    
    if canTrigger then
        -- å¯ç‚¹å‡»çŠ¶æ€ - äº®è‰²
        local btnGrad = nvgLinearGradient(nvg_, bx, by, bx, by + buttonHeight,
            nvgRGBA(80, 180, 80, 240),
            nvgRGBA(50, 140, 50, 240))
        nvgFillPaint(nvg_, btnGrad)
    else
        -- ä¸å¯ç‚¹å‡»çŠ¶æ€ - æš—è‰²
        nvgFillColor(nvg_, nvgRGBA(60, 60, 60, 200))
    end
    nvgFill(nvg_)
    
    -- æŒ‰é’®è¾¹æ¡†
    nvgBeginPath(nvg_)
    nvgRoundedRect(nvg_, bx, by, buttonWidth, buttonHeight, 10)
    if canTrigger then
        nvgStrokeColor(nvg_, nvgRGBA(150, 255, 150, 200))
    else
        nvgStrokeColor(nvg_, nvgRGBA(100, 100, 100, 150))
    end
    nvgStrokeWidth(nvg_, 3)
    nvgStroke(nvg_)
    
    -- æŒ‰é’®æ–‡å­—
    nvgFontFace(nvg_, "sans")
    nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
    
    if canTrigger then
        local remaining = math.ceil(waveDelay_ - waveTimer_)
        -- ä¸»æ–‡å­—
        nvgFontSize(nvg_, 24)
        nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
        nvgText(nvg_, bx + buttonWidth / 2, by + buttonHeight / 2 - 10, "ä¸‹ä¸€æ³¢ (" .. remaining .. "s)", nil)
        -- æç¤ºæ–‡å­—
        nvgFontSize(nvg_, 16)
        nvgFillColor(nvg_, nvgRGBA(200, 255, 200, 200))
        nvgText(nvg_, bx + buttonWidth / 2, by + buttonHeight / 2 + 14, "ç‚¹å‡»æˆ–æŒ‰ç©ºæ ¼", nil)
    elseif waveActive_ then
        nvgFontSize(nvg_, 22)
        nvgFillColor(nvg_, nvgRGBA(180, 180, 180, 200))
        nvgText(nvg_, bx + buttonWidth / 2, by + buttonHeight / 2, "æˆ˜æ–—ä¸­...", nil)
    else
        nvgFontSize(nvg_, 22)
        nvgFillColor(nvg_, nvgRGBA(150, 150, 150, 200))
        nvgText(nvg_, bx + buttonWidth / 2, by + buttonHeight / 2, "å·²å®Œæˆ", nil)
    end
end

function DrawEndScreen(width, height, isVictory)
    -- èƒŒæ™¯
    nvgBeginPath(nvg_)
    nvgRect(nvg_, 0, 0, width, height)
    if isVictory then
        nvgFillColor(nvg_, nvgRGBA(30, 60, 30, 240))
    else
        nvgFillColor(nvg_, nvgRGBA(60, 30, 30, 240))
    end
    nvgFill(nvg_)
    
    -- æ ‡é¢˜
    nvgFontFace(nvg_, "sans")
    nvgFontSize(nvg_, 72)
    nvgTextAlign(nvg_, NVG_ALIGN_CENTER + NVG_ALIGN_MIDDLE)
    
    if isVictory then
        nvgFillColor(nvg_, nvgRGBA(100, 255, 100, 255))
        nvgText(nvg_, width / 2, height / 2 - 140, "ğŸ‰ èƒœåˆ©ï¼", nil)
    else
        nvgFillColor(nvg_, nvgRGBA(255, 100, 100, 255))
        nvgText(nvg_, width / 2, height / 2 - 140, "ğŸ’€ å¤±è´¥", nil)
    end
    
    -- ç»Ÿè®¡ä¿¡æ¯
    nvgFontSize(nvg_, 28)
    nvgFillColor(nvg_, nvgRGBA(220, 220, 220, 255))
    nvgText(nvg_, width / 2, height / 2 - 50, "å‡»æ€æ•°: " .. totalKills_, nil)
    nvgText(nvg_, width / 2, height / 2, "æ€»é‡‘å¸: " .. totalGoldEarned_, nil)
    nvgText(nvg_, width / 2, height / 2 + 50, "å®Œæˆæ³¢æ¬¡: " .. currentWave_, nil)
    
    -- æŒ‰é’®
    local buttonWidth = 220
    local buttonHeight = 60
    local bx = (width - buttonWidth) / 2
    local by = height / 2 + 120
    
    -- é‡æ–°å¼€å§‹æŒ‰é’®
    nvgBeginPath(nvg_)
    nvgRoundedRect(nvg_, bx, by, buttonWidth, buttonHeight, 10)
    nvgFillColor(nvg_, nvgRGBA(80, 150, 80, 255))
    nvgFill(nvg_)
    
    nvgFontSize(nvg_, 26)
    nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
    nvgText(nvg_, bx + buttonWidth / 2, by + buttonHeight / 2, "é‡æ–°å¼€å§‹", nil)
    
    -- è¿”å›èœå•æŒ‰é’®
    by = by + 80
    nvgBeginPath(nvg_)
    nvgRoundedRect(nvg_, bx, by, buttonWidth, buttonHeight, 10)
    nvgFillColor(nvg_, nvgRGBA(100, 100, 150, 255))
    nvgFill(nvg_)
    
    nvgFillColor(nvg_, nvgRGBA(255, 255, 255, 255))
    nvgText(nvg_, bx + buttonWidth / 2, by + buttonHeight / 2, "è¿”å›èœå•", nil)
end
